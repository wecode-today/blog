{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/author.png","path":"img/author.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/jacman.jpg","path":"img/jacman.jpg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/banner.jpg","path":"img/banner.jpg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/banner.png","path":"img/banner.png","modified":1,"renderable":1}],"Cache":[{"_id":"themes/jacman/.gitignore","hash":"7d65523f2a5afb69d76824dd1dfa62a34faa3197","modified":1481727212000},{"_id":"themes/jacman/LICENSE","hash":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1481727212000},{"_id":"themes/jacman/README.md","hash":"0238076214f85d4f132f35aef5f52bdd1765ba37","modified":1481727212000},{"_id":"themes/jacman/README_zh.md","hash":"a74d856e31a563447b2c4befb0dea37485efeb02","modified":1481727212000},{"_id":"source/.DS_Store","hash":"c4dce41c8bbe1aa9cc0256fd8253bf7938e32a8e","modified":1487860699000},{"_id":"themes/jacman/_config.yml","hash":"453d58c61b1f280b8d515824a1510a96a891edde","modified":1481727212000},{"_id":"source/_drafts/mongodb3.md","hash":"16dd48f936c08b8ff1a40eb4a5e9c76292e4f121","modified":1481727212000},{"_id":"source/_posts/docker_clean.md","hash":"e224a7b28cb9783ef83ab15936e2f145262b70f8","modified":1481727212000},{"_id":"source/_posts/ruby_gil.md","hash":"e602e5176f0d11e1443fc685dcd9b11f9f289d2d","modified":1481727212000},{"_id":"source/_posts/ruby_json_error.md","hash":"4c22b628955e44128b7e5d7b6f74f2fd11a36ea9","modified":1481727212000},{"_id":"source/_posts/scchelv.md","hash":"532e6d1628a759733dbb826532747ec595fca5c8","modified":1481727212000},{"_id":"source/_posts/simple_cov.md","hash":"29115efa8215082a37760a60472a24e1f7739e3d","modified":1481727212000},{"_id":"source/_posts/topomatch_stackprof.md","hash":"830dbe639e1fbeef0819fbe8acf23c3c594567d9","modified":1481727212000},{"_id":"source/_posts/use_ocra.md","hash":"a3846e9b0782f5b9dbfde8e9f9b0c613fbc1aecf","modified":1481727212000},{"_id":"source/_posts/uru_ruby_select.md","hash":"0b038db934fb73651731e3212b91e0cef3feffa8","modified":1481727212000},{"_id":"themes/jacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1481727212000},{"_id":"themes/jacman/layout/layout.ejs","hash":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1481727212000},{"_id":"themes/jacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1481727212000},{"_id":"themes/jacman/layout/index.ejs","hash":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1481727212000},{"_id":"themes/jacman/languages/default.yml","hash":"ad0de3e82c7fc238cc067ffc37359b1420aef6b3","modified":1481727212000},{"_id":"themes/jacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1481727212000},{"_id":"themes/jacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1481727212000},{"_id":"themes/jacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1481727212000},{"_id":"themes/jacman/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1481727212000},{"_id":"themes/jacman/languages/zh-CN.yml","hash":"5e4ac19d7b2bbf0d5b5aa55d33653380abda8b9a","modified":1481727212000},{"_id":"themes/jacman/languages/zh-TW.yml","hash":"41c112162d79b4d3f97b417c7cd6ca6d70419ef2","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/analytics.ejs","hash":"fd004beb8d4500afd5fb3b3871a95afa2a375f16","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/archive.ejs","hash":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/article.ejs","hash":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","hash":"fc979ef6dc916f6d9880b3d085b7cdc6c82d3127","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/footer.ejs","hash":"4348d893004d6fbfd8883899853b59998defd815","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/article_row.ejs","hash":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/head.ejs","hash":"cfb1f091bf4c0312f73835d846787156f0e011dc","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/categories.ejs","hash":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/header.ejs","hash":"0c3dbe0e09bd0d7a7904a1c1797790e4bf8faf65","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","hash":"80b7c13a0de54c2224f52881f4195c27a71520d5","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/pagination.ejs","hash":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/search.ejs","hash":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","hash":"c4f527fff0070fbe65919053a16224412317f40d","modified":1481727212000},{"_id":"themes/jacman/layout/_widget/archive.ejs","hash":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/tags.ejs","hash":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/totop.ejs","hash":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1481727212000},{"_id":"themes/jacman/layout/_widget/category.ejs","hash":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1481727212000},{"_id":"themes/jacman/layout/_widget/links.ejs","hash":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1481727212000},{"_id":"themes/jacman/layout/_widget/douban.ejs","hash":"94ce1fb7a1143f34ac1365924b00cae64e1a111e","modified":1481727212000},{"_id":"themes/jacman/layout/_widget/rss.ejs","hash":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1481727212000},{"_id":"themes/jacman/layout/_widget/tag.ejs","hash":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1481727212000},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","hash":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1481727212000},{"_id":"themes/jacman/layout/_widget/weibo.ejs","hash":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1481727212000},{"_id":"themes/jacman/source/css/style.styl","hash":"89070fcce9a70c82ea5559ae8f6efc60e624c6d3","modified":1481727212000},{"_id":"themes/jacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1481727212000},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1481727212000},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1481727212000},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1481727212000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1481727212000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1481727212000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1481727212000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1481727212000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1481727212000},{"_id":"themes/jacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1481727212000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1481727212000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1481727212000},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1481727212000},{"_id":"themes/jacman/source/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1481727212000},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1481727212000},{"_id":"themes/jacman/source/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1481727212000},{"_id":"themes/jacman/source/img/author.png","hash":"95e03d1ee7d33558a0063ceb149fc3577312ea34","modified":1481727212000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1481727212000},{"_id":"themes/jacman/source/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1481727212000},{"_id":"themes/jacman/source/img/jacman.jpg","hash":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1481727212000},{"_id":"themes/jacman/source/img/favicon.png","hash":"0a82473f0042f9311d8d4731a79e999d9825b9e3","modified":1481727212000},{"_id":"themes/jacman/source/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1481727212000},{"_id":"themes/jacman/source/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1481727212000},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1481727212000},{"_id":"themes/jacman/source/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1481727212000},{"_id":"themes/jacman/source/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1481727212000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1481727212000},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1481727212000},{"_id":"themes/jacman/source/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1481727212000},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1481727212000},{"_id":"themes/jacman/source/img/logo.png","hash":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","hash":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","hash":"c88bc8f5805173920a5fdd7e9234a850e3d8e151","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","hash":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/post/article.ejs","hash":"b09e3acea7076e1f01dfe0c2295e19951ea09437","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/post/header.ejs","hash":"6d789715314a00915dc4518f8a0a6d4205ab6fd3","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","hash":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","hash":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1481727212000},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","hash":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1481727212000},{"_id":"themes/jacman/source/css/_base/font.styl","hash":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1481727212000},{"_id":"themes/jacman/source/css/_base/code.styl","hash":"a7fe002222bfc7a125c8fe92b26ba9dc604595a2","modified":1481727212000},{"_id":"themes/jacman/source/css/_base/public.styl","hash":"a29e4a4fbc288323b7f3ca2e501a6609e5646e2f","modified":1481727212000},{"_id":"themes/jacman/source/css/_base/variable.styl","hash":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1481727212000},{"_id":"themes/jacman/source/css/_partial/aside.styl","hash":"6b0e46e2e3be200339197696f5aabd0871aa9952","modified":1481727212000},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","hash":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1481727212000},{"_id":"themes/jacman/source/css/_partial/footer.styl","hash":"2dba2f347a68e11ac7b404d9370b2953e0e9a72c","modified":1481727212000},{"_id":"themes/jacman/source/css/_partial/gallery.styl","hash":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1481727212000},{"_id":"themes/jacman/source/css/_partial/article.styl","hash":"5ca0d6a053c48f922a28d0af0e04280f5388e7b8","modified":1481727212000},{"_id":"themes/jacman/source/css/_partial/header.styl","hash":"5121ceb712be3f2dde98b8b6e589b546e19eab8f","modified":1481727212000},{"_id":"themes/jacman/source/css/_partial/helper.styl","hash":"e5238015ac6ef5ed458d307a0aa52fda03c295f7","modified":1481727212000},{"_id":"themes/jacman/source/css/_partial/index.styl","hash":"864fba1fcb3830a9055c366a99ce5c951c2e9fe9","modified":1481727212000},{"_id":"themes/jacman/source/css/_partial/totop.styl","hash":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1481727212000},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1481727212000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1481727212000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1481727212000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1481727212000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1481727212000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1481727212000},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1481727212000},{"_id":"themes/jacman/source/img/banner.jpg","hash":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1481727212000},{"_id":"themes/jacman/source/img/banner.png","hash":"0df5526b0ce6320fdaf53993f63c19e92a771466","modified":1481727212000}],"Category":[{"name":"docker","_id":"cizij4bis0003p6ddylbvqxn5"},{"name":"ruby","_id":"cizij4bj00008p6dda22gnci3"},{"name":"web","_id":"cizij4bje000hp6ddg84j2mo3"}],"Data":[],"Page":[],"Post":[{"_content":"fdisk /dev/xvde\n\n> Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel\nBuilding a new DOS disklabel with disk identifier 0xca14dbcd.\nChanges will remain in memory only, until you decide to write them.\nAfter that, of course, the previous content won't be recoverable.\n\nWarning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)\n\nCommand (m for help): m\nCommand action\n   a   toggle a bootable flag\n   b   edit bsd disklabel\n   c   toggle the dos compatibility flag\n   d   delete a partition\n   l   list known partition types\n   m   print this menu\n   n   add a new partition\n   o   create a new empty DOS partition table\n   p   print the partition table\n   q   quit without saving changes\n   s   create a new empty Sun disklabel\n   t   change a partition's system id\n   u   change display/entry units\n   v   verify the partition table\n   w   write table to disk and exit\n   x   extra functionality (experts only)\n\nCommand (m for help): n\nPartition type:\n   p   primary (0 primary, 0 extended, 4 free)\n   e   extended\nSelect (default p): p\nPartition number (1-4, default 1): \nUsing default value 1\nFirst sector (2048-377487359, default 2048): \nUsing default value 2048\nLast sector, +sectors or +size{K,M,G} (2048-377487359, default 377487359): \nUsing default value 377487359\n\nCommand (m for help): w\nThe partition table has been altered!\n\nCalling ioctl() to re-read partition table.\nSyncing disks.\n\n> mkfs.ext4 /dev/xvde1\n\nmke2fs 1.42 (29-Nov-2011)\nFilesystem label=\nOS type: Linux\nBlock size=4096 (log=2)\nFragment size=4096 (log=2)\nStride=0 blocks, Stripe width=0 blocks\n11796480 inodes, 47185664 blocks\n2359283 blocks (5.00%) reserved for the super user\nFirst data block=0\nMaximum filesystem blocks=4294967296\n1440 block groups\n32768 blocks per group, 32768 fragments per group\n8192 inodes per group\nSuperblock backups stored on blocks: \n  32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, \n  4096000, 7962624, 11239424, 20480000, 23887872\n\nAllocating group tables: done                            \nWriting inode tables: done                            \nCreating journal (32768 blocks): done\nWriting superblocks and filesystem accounting information: done  \n\n> mkdir /data\n> mount /dev/xvde1 /data\n\n> df -h\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/xvda2       36G  3.0G   31G   9% /\nudev            3.9G  4.0K  3.9G   1% /dev\ntmpfs           1.6G  748K  1.6G   1% /run\nnone            5.0M     0  5.0M   0% /run/lock\nnone            3.7G  4.0K  3.7G   1% /run/shm\n/dev/xvde1      178G  188M  168G   1% /data\n\n# 编辑fstab\n> UUID=7e9b077b-d488-461c-81cf-4bc18cb58d8c /data         auto    defaults        0       0\n\n> chown -R mongodb:mongodb /data/db\n","source":"_drafts/mongodb3.md","raw":"fdisk /dev/xvde\n\n> Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel\nBuilding a new DOS disklabel with disk identifier 0xca14dbcd.\nChanges will remain in memory only, until you decide to write them.\nAfter that, of course, the previous content won't be recoverable.\n\nWarning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)\n\nCommand (m for help): m\nCommand action\n   a   toggle a bootable flag\n   b   edit bsd disklabel\n   c   toggle the dos compatibility flag\n   d   delete a partition\n   l   list known partition types\n   m   print this menu\n   n   add a new partition\n   o   create a new empty DOS partition table\n   p   print the partition table\n   q   quit without saving changes\n   s   create a new empty Sun disklabel\n   t   change a partition's system id\n   u   change display/entry units\n   v   verify the partition table\n   w   write table to disk and exit\n   x   extra functionality (experts only)\n\nCommand (m for help): n\nPartition type:\n   p   primary (0 primary, 0 extended, 4 free)\n   e   extended\nSelect (default p): p\nPartition number (1-4, default 1): \nUsing default value 1\nFirst sector (2048-377487359, default 2048): \nUsing default value 2048\nLast sector, +sectors or +size{K,M,G} (2048-377487359, default 377487359): \nUsing default value 377487359\n\nCommand (m for help): w\nThe partition table has been altered!\n\nCalling ioctl() to re-read partition table.\nSyncing disks.\n\n> mkfs.ext4 /dev/xvde1\n\nmke2fs 1.42 (29-Nov-2011)\nFilesystem label=\nOS type: Linux\nBlock size=4096 (log=2)\nFragment size=4096 (log=2)\nStride=0 blocks, Stripe width=0 blocks\n11796480 inodes, 47185664 blocks\n2359283 blocks (5.00%) reserved for the super user\nFirst data block=0\nMaximum filesystem blocks=4294967296\n1440 block groups\n32768 blocks per group, 32768 fragments per group\n8192 inodes per group\nSuperblock backups stored on blocks: \n  32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, \n  4096000, 7962624, 11239424, 20480000, 23887872\n\nAllocating group tables: done                            \nWriting inode tables: done                            \nCreating journal (32768 blocks): done\nWriting superblocks and filesystem accounting information: done  \n\n> mkdir /data\n> mount /dev/xvde1 /data\n\n> df -h\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/xvda2       36G  3.0G   31G   9% /\nudev            3.9G  4.0K  3.9G   1% /dev\ntmpfs           1.6G  748K  1.6G   1% /run\nnone            5.0M     0  5.0M   0% /run/lock\nnone            3.7G  4.0K  3.7G   1% /run/shm\n/dev/xvde1      178G  188M  168G   1% /data\n\n# 编辑fstab\n> UUID=7e9b077b-d488-461c-81cf-4bc18cb58d8c /data         auto    defaults        0       0\n\n> chown -R mongodb:mongodb /data/db\n","slug":"mongodb3","published":0,"date":"2016-12-14T14:53:32.000Z","updated":"2016-12-14T14:53:32.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cizij4bi00000p6ddc5u29apb","content":"<p>fdisk /dev/xvde</p>\n<blockquote>\n<p>Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel<br>Building a new DOS disklabel with disk identifier 0xca14dbcd.<br>Changes will remain in memory only, until you decide to write them.<br>After that, of course, the previous content won’t be recoverable.</p>\n</blockquote>\n<p>Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)</p>\n<p>Command (m for help): m<br>Command action<br>   a   toggle a bootable flag<br>   b   edit bsd disklabel<br>   c   toggle the dos compatibility flag<br>   d   delete a partition<br>   l   list known partition types<br>   m   print this menu<br>   n   add a new partition<br>   o   create a new empty DOS partition table<br>   p   print the partition table<br>   q   quit without saving changes<br>   s   create a new empty Sun disklabel<br>   t   change a partition’s system id<br>   u   change display/entry units<br>   v   verify the partition table<br>   w   write table to disk and exit<br>   x   extra functionality (experts only)</p>\n<p>Command (m for help): n<br>Partition type:<br>   p   primary (0 primary, 0 extended, 4 free)<br>   e   extended<br>Select (default p): p<br>Partition number (1-4, default 1):<br>Using default value 1<br>First sector (2048-377487359, default 2048):<br>Using default value 2048<br>Last sector, +sectors or +size{K,M,G} (2048-377487359, default 377487359):<br>Using default value 377487359</p>\n<p>Command (m for help): w<br>The partition table has been altered!</p>\n<p>Calling ioctl() to re-read partition table.<br>Syncing disks.</p>\n<blockquote>\n<p>mkfs.ext4 /dev/xvde1</p>\n</blockquote>\n<p>mke2fs 1.42 (29-Nov-2011)<br>Filesystem label=<br>OS type: Linux<br>Block size=4096 (log=2)<br>Fragment size=4096 (log=2)<br>Stride=0 blocks, Stripe width=0 blocks<br>11796480 inodes, 47185664 blocks<br>2359283 blocks (5.00%) reserved for the super user<br>First data block=0<br>Maximum filesystem blocks=4294967296<br>1440 block groups<br>32768 blocks per group, 32768 fragments per group<br>8192 inodes per group<br>Superblock backups stored on blocks:<br>  32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,<br>  4096000, 7962624, 11239424, 20480000, 23887872</p>\n<p>Allocating group tables: done<br>Writing inode tables: done<br>Creating journal (32768 blocks): done<br>Writing superblocks and filesystem accounting information: done  </p>\n<blockquote>\n<p>mkdir /data<br>mount /dev/xvde1 /data</p>\n<p>df -h<br>Filesystem      Size  Used Avail Use% Mounted on<br>/dev/xvda2       36G  3.0G   31G   9% /<br>udev            3.9G  4.0K  3.9G   1% /dev<br>tmpfs           1.6G  748K  1.6G   1% /run<br>none            5.0M     0  5.0M   0% /run/lock<br>none            3.7G  4.0K  3.7G   1% /run/shm<br>/dev/xvde1      178G  188M  168G   1% /data</p>\n</blockquote>\n<h1 id=\"编辑fstab\"><a href=\"#编辑fstab\" class=\"headerlink\" title=\"编辑fstab\"></a>编辑fstab</h1><blockquote>\n<p>UUID=7e9b077b-d488-461c-81cf-4bc18cb58d8c /data         auto    defaults        0       0</p>\n<p>chown -R mongodb:mongodb /data/db</p>\n</blockquote>\n","excerpt":"","more":"<p>fdisk /dev/xvde</p>\n<blockquote>\n<p>Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel<br>Building a new DOS disklabel with disk identifier 0xca14dbcd.<br>Changes will remain in memory only, until you decide to write them.<br>After that, of course, the previous content won’t be recoverable.</p>\n</blockquote>\n<p>Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)</p>\n<p>Command (m for help): m<br>Command action<br>   a   toggle a bootable flag<br>   b   edit bsd disklabel<br>   c   toggle the dos compatibility flag<br>   d   delete a partition<br>   l   list known partition types<br>   m   print this menu<br>   n   add a new partition<br>   o   create a new empty DOS partition table<br>   p   print the partition table<br>   q   quit without saving changes<br>   s   create a new empty Sun disklabel<br>   t   change a partition’s system id<br>   u   change display/entry units<br>   v   verify the partition table<br>   w   write table to disk and exit<br>   x   extra functionality (experts only)</p>\n<p>Command (m for help): n<br>Partition type:<br>   p   primary (0 primary, 0 extended, 4 free)<br>   e   extended<br>Select (default p): p<br>Partition number (1-4, default 1):<br>Using default value 1<br>First sector (2048-377487359, default 2048):<br>Using default value 2048<br>Last sector, +sectors or +size{K,M,G} (2048-377487359, default 377487359):<br>Using default value 377487359</p>\n<p>Command (m for help): w<br>The partition table has been altered!</p>\n<p>Calling ioctl() to re-read partition table.<br>Syncing disks.</p>\n<blockquote>\n<p>mkfs.ext4 /dev/xvde1</p>\n</blockquote>\n<p>mke2fs 1.42 (29-Nov-2011)<br>Filesystem label=<br>OS type: Linux<br>Block size=4096 (log=2)<br>Fragment size=4096 (log=2)<br>Stride=0 blocks, Stripe width=0 blocks<br>11796480 inodes, 47185664 blocks<br>2359283 blocks (5.00%) reserved for the super user<br>First data block=0<br>Maximum filesystem blocks=4294967296<br>1440 block groups<br>32768 blocks per group, 32768 fragments per group<br>8192 inodes per group<br>Superblock backups stored on blocks:<br>  32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,<br>  4096000, 7962624, 11239424, 20480000, 23887872</p>\n<p>Allocating group tables: done<br>Writing inode tables: done<br>Creating journal (32768 blocks): done<br>Writing superblocks and filesystem accounting information: done  </p>\n<blockquote>\n<p>mkdir /data<br>mount /dev/xvde1 /data</p>\n<p>df -h<br>Filesystem      Size  Used Avail Use% Mounted on<br>/dev/xvda2       36G  3.0G   31G   9% /<br>udev            3.9G  4.0K  3.9G   1% /dev<br>tmpfs           1.6G  748K  1.6G   1% /run<br>none            5.0M     0  5.0M   0% /run/lock<br>none            3.7G  4.0K  3.7G   1% /run/shm<br>/dev/xvde1      178G  188M  168G   1% /data</p>\n</blockquote>\n<h1 id=\"编辑fstab\"><a href=\"#编辑fstab\" class=\"headerlink\" title=\"编辑fstab\"></a>编辑fstab</h1><blockquote>\n<p>UUID=7e9b077b-d488-461c-81cf-4bc18cb58d8c /data         auto    defaults        0       0</p>\n<p>chown -R mongodb:mongodb /data/db</p>\n</blockquote>\n"},{"title":"docker镜像未清理导致磁盘空间满","date":"2016-12-15T02:53:00.000Z","_content":"\n# 简介\n我们的某个服务突然有一天，所有的测试环境全部执行失败，返回500。结果到某台测试服务器上一看，磁盘空间满了！\n\n最后发现是大量的历史版本Docker镜像未清理导致的：\n\n```\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              8470735ac8e2        4 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              d88765ddc8fe        5 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              4aee0b83558a        6 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              add02e6af8f5        6 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              97eb4f2da485        6 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              95b8f4d92383        6 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              a2b51b2e138a        7 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              3b250877a8e1        7 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              3aa940434a99        7 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              68b1ec83803c        7 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              951db5450246        8 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              73b1750b31b9        8 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              13e7b553b4b7        8 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              4ea2c3cdc7bc        8 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              a5bc7cef75d0        8 weeks ago         1.121 GB\n```\n\n在网络上查询了之后，可以使用`docker rmi $(docker images -q -f dangling=true)`命令来清理untagged镜像。执行之后清理出大概25G的空间。\n\n```\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/xvda2       36G  5.4G   29G  16% /\n```\n\n# 优化部署\n由于测试版本的应用，版本号总是`lastest`，因此每部署一次就留下了一个untagged镜像。所以我们把清理脚本加入部署阶段，部署最新版本之前先执行一次清理。\n\n```\necho \"Clean old docker images\"\ndocker rm $(docker ps -a -q)\ndocker rmi $(docker images -q -f dangling=true)\n```\n这样就能减少大量的untagged镜像，节省磁盘空间。\n","source":"_posts/docker_clean.md","raw":"title: docker镜像未清理导致磁盘空间满\ndate: 2016/12/15 10:53:00\ncategories:\n  - docker\ntags:\n  - clean\n  - docker\n  - shell\n---\n\n# 简介\n我们的某个服务突然有一天，所有的测试环境全部执行失败，返回500。结果到某台测试服务器上一看，磁盘空间满了！\n\n最后发现是大量的历史版本Docker镜像未清理导致的：\n\n```\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              8470735ac8e2        4 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              d88765ddc8fe        5 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              4aee0b83558a        6 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              add02e6af8f5        6 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              97eb4f2da485        6 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              95b8f4d92383        6 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              a2b51b2e138a        7 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              3b250877a8e1        7 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              3aa940434a99        7 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              68b1ec83803c        7 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              951db5450246        8 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              73b1750b31b9        8 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              13e7b553b4b7        8 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              4ea2c3cdc7bc        8 weeks ago         1.121 GB\nnoah-docker.host.huawei.com/noah-service/hunter         <none>              a5bc7cef75d0        8 weeks ago         1.121 GB\n```\n\n在网络上查询了之后，可以使用`docker rmi $(docker images -q -f dangling=true)`命令来清理untagged镜像。执行之后清理出大概25G的空间。\n\n```\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/xvda2       36G  5.4G   29G  16% /\n```\n\n# 优化部署\n由于测试版本的应用，版本号总是`lastest`，因此每部署一次就留下了一个untagged镜像。所以我们把清理脚本加入部署阶段，部署最新版本之前先执行一次清理。\n\n```\necho \"Clean old docker images\"\ndocker rm $(docker ps -a -q)\ndocker rmi $(docker images -q -f dangling=true)\n```\n这样就能减少大量的untagged镜像，节省磁盘空间。\n","slug":"docker_clean","published":1,"updated":"2016-12-14T14:53:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizij4bim0001p6ddmlm0zr02","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>我们的某个服务突然有一天，所有的测试环境全部执行失败，返回500。结果到某台测试服务器上一看，磁盘空间满了！</p>\n<p>最后发现是大量的历史版本Docker镜像未清理导致的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              8470735ac8e2        4 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              d88765ddc8fe        5 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              4aee0b83558a        6 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              add02e6af8f5        6 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              97eb4f2da485        6 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              95b8f4d92383        6 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              a2b51b2e138a        7 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              3b250877a8e1        7 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              3aa940434a99        7 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              68b1ec83803c        7 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              951db5450246        8 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              73b1750b31b9        8 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              13e7b553b4b7        8 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              4ea2c3cdc7bc        8 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              a5bc7cef75d0        8 weeks ago         1.121 GB</div></pre></td></tr></table></figure>\n<p>在网络上查询了之后，可以使用<code>docker rmi $(docker images -q -f dangling=true)</code>命令来清理untagged镜像。执行之后清理出大概25G的空间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Filesystem      Size  Used Avail Use% Mounted on</div><div class=\"line\">/dev/xvda2       36G  5.4G   29G  16% /</div></pre></td></tr></table></figure>\n<h1 id=\"优化部署\"><a href=\"#优化部署\" class=\"headerlink\" title=\"优化部署\"></a>优化部署</h1><p>由于测试版本的应用，版本号总是<code>lastest</code>，因此每部署一次就留下了一个untagged镜像。所以我们把清理脚本加入部署阶段，部署最新版本之前先执行一次清理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo &quot;Clean old docker images&quot;</div><div class=\"line\">docker rm $(docker ps -a -q)</div><div class=\"line\">docker rmi $(docker images -q -f dangling=true)</div></pre></td></tr></table></figure>\n<p>这样就能减少大量的untagged镜像，节省磁盘空间。</p>\n","excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>我们的某个服务突然有一天，所有的测试环境全部执行失败，返回500。结果到某台测试服务器上一看，磁盘空间满了！</p>\n<p>最后发现是大量的历史版本Docker镜像未清理导致的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              8470735ac8e2        4 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              d88765ddc8fe        5 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              4aee0b83558a        6 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              add02e6af8f5        6 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              97eb4f2da485        6 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              95b8f4d92383        6 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              a2b51b2e138a        7 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              3b250877a8e1        7 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              3aa940434a99        7 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              68b1ec83803c        7 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              951db5450246        8 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              73b1750b31b9        8 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              13e7b553b4b7        8 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              4ea2c3cdc7bc        8 weeks ago         1.121 GB</div><div class=\"line\">noah-docker.host.huawei.com/noah-service/hunter         &lt;none&gt;              a5bc7cef75d0        8 weeks ago         1.121 GB</div></pre></td></tr></table></figure>\n<p>在网络上查询了之后，可以使用<code>docker rmi $(docker images -q -f dangling=true)</code>命令来清理untagged镜像。执行之后清理出大概25G的空间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Filesystem      Size  Used Avail Use% Mounted on</div><div class=\"line\">/dev/xvda2       36G  5.4G   29G  16% /</div></pre></td></tr></table></figure>\n<h1 id=\"优化部署\"><a href=\"#优化部署\" class=\"headerlink\" title=\"优化部署\"></a>优化部署</h1><p>由于测试版本的应用，版本号总是<code>lastest</code>，因此每部署一次就留下了一个untagged镜像。所以我们把清理脚本加入部署阶段，部署最新版本之前先执行一次清理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo &quot;Clean old docker images&quot;</div><div class=\"line\">docker rm $(docker ps -a -q)</div><div class=\"line\">docker rmi $(docker images -q -f dangling=true)</div></pre></td></tr></table></figure>\n<p>这样就能减少大量的untagged镜像，节省磁盘空间。</p>\n"},{"title":"Ruby GIL之谜","date":"2015-04-18T13:44:00.000Z","_content":"> 从[jstorimer](http://www.jstorimer.com/blogs/workingwithcode/8085491-nobody-understands-the-gil)的博客翻译\n\n# Nobody understands the GIL Part1 \n## 什么是GIL\n提起Ruby的多线程，就不得不说Ruby里面的GIL。GIL全称是`Global Interpreter Lock`（全局解释器锁），那么GIL到底是啥呢？\n\n```\nMRI有一个全局的解释器锁。它用于锁住Ruby代码的执行。这意味着在一个多线程环境中，在同一个时间，只有一个线程能够执行Ruby代码。\n```\n\n因此，如果你有8个线程，工作在一个8核的CPU机器上，在任何时间中，只有一个线程能够在其中一个核上运行（不过这个不一定表示每次都运行在同一个核心上）。GIL用于保护Ruby内部，用于防止产生竞争环境(race condition)，进而导致数据损坏。\n\n## 问题\n\n## 往数组中增加数据不是线程安全的\n\n在Ruby中，只有很少的操作默认是线程安全的。比如，往数组中增加元素：\n\n```ruby\narray = []\n\n5.times.map do\n  Thread.new do\n    1000.times do\n      array << nil\n    end\n  end\nend.each(&:join)\n\nputs array.size\n```\n\n这里有5个线程共享1个数组对象。每个线程往数组里面`push`1000次`nil`。所以到最后，数组里面应该有5000个nil，是吧？\n\n```\n$ ruby pushing_nil.rb\n5000\n```\n\n```\n$ jruby pushing_nil.rb\n4446\n```\n\n```\n$ rbx pushing_nil.rb\n3088\n```\n\n这么一个简单地例子，已经暴露出Ruby的一个操作不是线程安全的。在这里到底发生了什么？\n\n<!-- more -->\n\n请注意MRI实现产生了正确的结果 5000 。JRuby和Rubinius产生了错误的结果。如果你重新运行脚本，你可能会发现MRI再一次返回正确结果，但是JRuby和Rubinius产生了不同的错误结果。    \n\n结果不一致的原因就是应为GIL。因为MRI有GIL，虽然说有5个线程都在运行，实际上一次只有一个线程是活动的。换句话说，执行不是并行的。JRuby和Rubinius因为没有GIL，当你有5个线程在运行时，你真的有5个线程同时在所有的CPU核心上运行！\n\n在那些支持并行的Ruby实现上，5个线程都进入运行线程不安全的代码。它们相互影响，最终导致破坏底层数据。\n\n## 多线程如何破坏数据\n\n怎么会这样呢？Ruby不是程序员最好的朋友吗？我会给你展示一些基于高阶解释的技术细节，也会给你展示这个从技术上来说是可能的。\n\n当你使用MRI,JRuby,Rubinius的时候，不同的Ruby实现采用了不同的语言。MRI是C语言写的，JRuby使用Java编写，Rubinius是使用Ruby和C++混合实现的。因此当你有如下的Ruby语句：\n\n```ruby\narray << nil\n```\n\n这条语句会转换为几十上百条底层代码。以MRI的`Array#<<`方法为例：\n\n```c\nVALUE\nrb_ary_push(VALUE ary, VALUE item)\n{\n    long idx = RARRAY_LEN(ary);\n\n    ary_ensure_room_for_push(ary, 1);\n    RARRAY_ASET(ary, idx, item);\n    ARY_SET_LEN(ary, idx + 1);\n    return ary;\n}\n```\n\n请注意：这里至少有 **4条底层操作** 。\n\n1. 获取当前数组的长度。\n2. 检查数组中是否有空间用于插入新数据\n3. 将新数据附加到数组\n4. 设定数组的长度为旧长度+1\n\n每条这种操作又会调用其他函数或者宏。我会将这个的目的是，给你看看多线程是如何损坏数据的。在单线程环境中，你可以看看这段C代码，并且可以很容易地跟踪函数的执行路径。换句话说，我们已经习惯了通过代码以线性的方式，推理整个'世界'的状态。这就是我们通常编写代码的方式。\n\n当涉及多个线程，这不再是可能的了。当有两个线程，每个线程通过代码跟踪其自己的路径。现在，你必须保持2 （或以上）的'指针'，指向每个正在执行的线程。因为线程共享相同的内存空间（同一个进程中），两个线程可同时改变“世界”的状态。\n\n一个线程中断另一个线程的执行，改变了另外一个线程的内部状态，然后另外的线程继续执行，完全不知道的事物的状态发生了变化。这种情况是完全可能的。\n\n这就是为什么一些Ruby实现，往数组中简单地附加数据也会产生错误结果的原因。请看下图：\n\n这里是我们的初始系统状态。\n\n![append_base](http://7vzu7z.com1.z0.glb.clouddn.com/2015/4/19/append_base_grande.png)\n\n这里有两个活动线程，同时进入了这个函数。考虑第1-4步是这个函数(`Array#<<`)实现的伪代码。一旦两个线程都进入这个函数，这里是一个可能出现的执行顺序，以线程A开始。\n\n![append_arrows_grande](http://7vzu7z.com1.z0.glb.clouddn.com/2015/4/19/append_arrows_grande.png)\n\n这个看起来有些复杂，但是只需要跟着箭头指向的顺序来了解这里发生了什么。在每个步骤上，我增加了小标签，用于从每个线程的角度来显示状态变化。\n\n这只是其中一种可能的执行序列。\n\n在此发生的是：线程A开始按顺序路径执行此函数，不过当它执行到第三步的时候，它遇到了上下文切换。因此线程A就在此地方暂停执行。此时线程B开始执行，它执行完整个函数，将元素附加到数组末尾并增加数组长度属性。\n\n一旦线程B执行完成，线程A恢复上下文，从中断的地方继续执行。记住，线程A在增加长度属性之前被暂停，因此它继续执行并增加数组长度。只不过它并不知道线程B在它的眼皮子底下修改了状态。\n\n线程B将长度设置为1，然后线程A将长度设置为1，两个都已经将元素附加到数组末尾。数据就这样被破坏掉了，这个事件顺序就是导致JRuby或者Rubinius结果不正确的原因。\n\n除此之外，在JRuby和Rubinius中，通常还有更为复杂的情况并发执行。在这种情况下，一个线程被暂停后，同时并行运行的其他线程，所有的线程都有可能在同一时间处理数据。\n\n如果你重复执行测试脚本，你会发现不正确的结果每次都不相同。这里线程切换是 **非确定性的，不可预知的** ，它完全有可能发生在函数执行前，执行后，或者没啥关系。\n\n**那为啥Ruby不帮我们搞定这些事情呢？** 其他编程语言的数组同理也不提供线程安全保障：代价太昂贵了。其他Ruby实现要提供线程安全的数据结构是可能的，但是会导致额外的开销，最终导致单线程程序执行变慢。而开发者的责任就是在需要的时候保证线程安全。\n\n那么问题来了，线程安全哪家强？Ruby实现找蓝翔…………\n\n如果这样的线程切换是可能的，那为什么MRI能够输出正确的结果呢？这个线程切换又到底是啥鬼东西？(ˇˍˇ） 想～)\n\n问题1就是我写这篇文章的原因。对于GIL的高阶理解是无法回答这个问题的。高阶理解只能知道一个时间只有一个线程在执行。但是当上下文切换在Ruby函数执行中发生的时候，会发生啥？什么是GIL语义？\n\n但是首先……\n\n## 都是调度器的错！\n\n上下文切换来自于操作系统的线程调度器。在所有的Ruby实现中，一个Ruby线程对应一个操作系统原生线程。操作系统保证没有一个线程会把系统的所有资源（比如CPU时间片）全部吃完，因此操作系统实现了线程的调度器，用于在各个线程中公平分配资源。\n\n这表现为一系列的暂停和恢复。每个线程都有机会用于占用一个时间片资源，然后它被暂停并记录上下文，其他线程就有它们的机会执行。随着时间的推移，这个线程将被恢复执行，如此反复。\n\n这对于操作系统来说是很有效的，不过给你的程序带来了一定程度上的随机性。例如`Array#<<`方法就需要察觉它可能在任何时间被暂停，然后另外的线程并行执行同样的操作，在它的眼皮底下修改'整个世界'的状态。\n\n**怎么办？将操作原子化。**\n\n如果你需要确保操作不被中断，那么需要将操作原子化。如此你就确保在操作完成之前不会被中断。这样就可以防止我们前面例子的第三步，最终当它恢复执行第4步的时候，防止损坏数据。\n\n原子化操作最简单的方式就是使用锁。以下代码确保在MRI，JRuby和Rubinius上都可以输出正确结果。\n\n```ruby\narray = []\nmutex = Mutex.new\n\n5.times.map do\n  Thread.new do\n\n    mutex.synchronize do\n      1000.times do\n        array << nil\n      end\n    end\n\n  end\nend.each(&:join)\n\nputs array.size\n```\n\n这段代码使用了一个共享互斥量或者锁来确保执行结果正确。一旦一个线程进入了`mutex.synchronize`代码块，其他所有线程必须等到当前线程将代码块执行完成后，才能进入同样地代码。通过将操作原子化，你确保了在代码块里即使发生了上下文切换，其他线程也无法进入同样的代码。线程调度器可以看到这个，将调度重新切换到其他线程上。这同时也确保了其他线程无法修改'世界状态'。这就是线程安全。\n\n## GIL也是一把锁\n\n我已经给你展示了如何使用锁来将操作原子化，并提供线程安全保证。GIL也是一个锁，那么它确保了你的所有Ruby代码都是线程安全的吗？它确保`Array#<<`操作原子化吗？\n\n# Nobody understands the GIL Part2\n\n在第一部分我们留下了2个问题:\n\n1. GIL确保`array << nil`是原子操作吗？\n2. GIL确保你的Ruby代码线程安全吗？\n\n第一个操作我们通过查看源代码来解决。\n\n回忆一下上次的代码片段：\n\n```ruby\narray = []\n\n5.times.map do\n  Thread.new do\n    1000.times do\n      array << nil\n    end\n  end\nend.each(&:join)\n\nputs array.size\n```\n\n如果你假设数组是线程安全的，那么期望的结果应该是5000。但是由于数组不是线程安全的，因此JRuby和Rubinius产生了一个非预期的结果--小于5000。这就是多个线程的上下文切换导致损坏数据的原因。\n\n**MRI产生了预期结果，但它是侥幸还是担保呢？** 我们通过查看Ruby的源代码片段来学习：\n\n```ruby\nThread.new do\n  array << nil\nend\n```\n\n## 从头说起\n\n要知道这段代码内部发生了啥，我们需要看看MRI是如何启动线程的。我们会查看MRI源代码的[thread.c](https://github.com/ruby/ruby/blob/trunk/thread.c)文件。\n\n第一段开始的代码`Thread.new`是启动了一个原生线程来支撑ruby线程。启动线程的函数是`thread_start_func_2`。我们从大的方向来看看这个函数。\n\n```c\nstatic int\nthread_start_func_2(rb_thread_t *th, VALUE *stack_start, VALUE *register_stack_start)\n{\n    int state;\n    VALUE args = th->first_args;\n    rb_proc_t *proc;\n    rb_thread_list_t *join_list;\n    rb_thread_t *main_th;\n    VALUE errinfo = Qnil;\n    if (th == th->vm->main_thread)\n  \n    ruby_thread_set_native(th);\n\n    th->machine.stack_start = stack_start;\n    thread_debug(\"thread start: %p\\n\", (void *)th);\n\n    gvl_acquire(th->vm, th);    // **获取GIL锁**\n    {\n      thread_debug(\"thread start (get lock): %p\\n\", (void *)th);\n      rb_thread_set_current(th);    // **设定当前线程**\n\n      TH_PUSH_TAG(th);\n      if ((state = EXEC_TAG()) == 0) {\n          SAVE_ROOT_JMPBUF(th, {\n                    native_set_thread_name(th);\n        if (!th->first_func) {\n            GetProcPtr(th->first_proc, proc);\n            th->errinfo = Qnil;\n            th->root_lep = rb_vm_ep_local_ep(proc->block.ep);\n            th->root_svar = Qnil;\n            EXEC_EVENT_HOOK(th, RUBY_EVENT_THREAD_BEGIN, th->self, 0, 0, Qundef);\n            th->value = rb_vm_invoke_proc(th, proc, (int)RARRAY_LEN(args), RARRAY_CONST_PTR(args), 0);  // 执行线程代码块\n            EXEC_EVENT_HOOK(th, RUBY_EVENT_THREAD_END, th->self, 0, 0, Qundef);\n        }\n        else {\n            th->value = (*th->first_func)((void *)args);\n        }\n          });\n      }\n      else {\n        ...\n      }\n\n      th->status = THREAD_KILLED;\n      thread_debug(\"thread end: %p\\n\", (void *)th);\n\n      main_th = th->vm->main_thread;\n      if (main_th == th) {\n          ruby_stop(0);\n      }\n      if (RB_TYPE_P(errinfo, T_OBJECT)) {\n          /* treat with normal error object */\n          rb_threadptr_raise(main_th, 1, &errinfo);\n      }\n      TH_POP_TAG();\n\n      /* locking_mutex must be Qfalse */\n      if (th->locking_mutex != Qfalse) {\n          rb_bug(\"thread_start_func_2: locking_mutex must not be set (%p:%\"PRIxVALUE\")\",\n           (void *)th, th->locking_mutex);\n      }\n\n      /* delete self other than main thread from living_threads */\n      rb_vm_living_threads_remove(th->vm, th);\n      if (rb_thread_alone()) {\n          /* I'm last thread. wake up main thread from rb_thread_terminate_all */\n          rb_threadptr_interrupt(main_th);\n      }\n\n      /* wake up joining threads */\n      join_list = th->join_list;\n      while (join_list) {\n          rb_threadptr_interrupt(join_list->th);\n          switch (join_list->th->status) {\n            case THREAD_STOPPED: case THREAD_STOPPED_FOREVER:\n        join_list->th->status = THREAD_RUNNABLE;\n            default: break;\n          }\n          join_list = join_list->next;\n      }\n\n      rb_threadptr_unlock_all_locking_mutexes(th);\n      rb_check_deadlock(th->vm);\n\n      if (!th->root_fiber) {\n          rb_thread_recycle_stack_release(th->stack);\n          th->stack = 0;\n      }\n    }\n    native_mutex_lock(&th->vm->thread_destruct_lock);\n    /* make sure vm->running_thread never point me after this point.*/\n    th->vm->running_thread = NULL;\n    native_mutex_unlock(&th->vm->thread_destruct_lock);\n    thread_cleanup_func(th, FALSE);\n    gvl_release(th->vm);  // **释放GIL**\n\n    return 0;\n}\n```\n \n这个函数中有很多代码，不过我们着重看加了注释的部分。在顶部，这个新线程会获取GIL。记住，这个线程在实际拿到GIL之前，都是空闲的。在代码中间，它调用你传给线程的代码块。在完成这些之后，它释放GIL并退出原生线程。\n\n在我们的代码片段里，这个新线程是由主线程启动的。基于这个情况，我们可以假设主线程当前持有GIL。在主线程释放GIL之前，这个新线程只能等待。\n\n我们看看当这个新线程想要获取GIL时发生了啥(Linux平台)：\n\n```c\nstatic void\ngvl_acquire_common(rb_vm_t *vm)\n{\n    if (vm->gvl.acquired) {\n        vm->gvl.waiting++;\n        if (vm->gvl.waiting == 1) {\n            /*\n             * Wake up timer thread iff timer thread is slept.\n             * When timer thread is polling mode, we don't want to\n             * make confusing timer thread interval time.\n             */\n            rb_thread_wakeup_timer_thread_low();\n        }\n\n        while (vm->gvl.acquired) {\n            native_cond_wait(&vm->gvl.cond, &vm->gvl.lock);\n        }\n\n        vm->gvl.waiting--;\n\n        if (vm->gvl.need_yield) {\n            vm->gvl.need_yield = 0;\n            native_cond_signal(&vm->gvl.switch_cond);\n        }\n    }\n\n    vm->gvl.acquired = 1;\n}\n```\n\n\n这个是Linux平台上的`gvl_acquire_common`函数。这个函数被`gvl_acquire`函数调用，用于获取GIL。\n\n首先它检查当前是否已经获取了GIL。如果是，那么就增加GIL的waiting属性。对于我们的执行代码来说，这个值现在应该是1。下面的代码用于检查等待值是否为1.如果是，下一行代码就触发定时器线程的唤醒。\n\n定时器线程是MRI的秘密武器，用于MRI线程系统的顺畅，并防止任何一个线程长时间占用GIL。但在此之前，我们不要跑那么快，先让说明GIL的一些信息，再介绍该定时器线程。\n\n![pre-gil_2_medium](http://7vzu7z.com1.z0.glb.clouddn.com/2015/4/24/pre-gil_2_medium.png)\n我已经说过，MRI线程对应一个原生操作系统线程。但是这张图表示每个MRI线程是在它的原生线程上并行执行的。GIL防止了这个。我们需要将GIL加入到图中，将图标变得更为现实。\n\n![with-gil_medium](http://7vzu7z.com1.z0.glb.clouddn.com/2015/4/24/with-gil_medium.png)\n\n当Ruby线程想在它的原生线程里面执行代码时，它必须要首先获取GIL。**GIL作为Ruby线程和底层原生线程的中间者，严重降低了并行！在前一张图中，多个Ruby线程和其底层的原生线程都是并行执行的。第二张图更接近于MRI，在任何时间，只有一个线程能够获取到GIL，因此MRI中并行执行代码完全被禁止。\n\n**根据MRI开发组成员的说法，GIL保护了系统内部状态。** 由于有GIL，它们不需要显示获取锁，或者对内部数据进行同步。如果两个线程无法同时修改内部状态，那么就不存在竞争环境。\n\n对于开发者，这会严重限制你的代码在MRI上无法并行执行。\n\n## 定时器线程\n\n我已经说过了，定时器线程是用于防止其他线程霸占GIL的。定时器线程是MRI的一个内部原生线程，它没有关联的Ruby线程。定时器线程由MRI函数`rb_thread_create_timer_thread`方法启动。\n\n当MRI启动后只有主线程在运行时，定时器线程处于睡眠状态。但记住，一旦一个线程开始等待GIL，它就唤醒定时器线程。\n\n![sleeping-timer_large](http://7vzu7z.com1.z0.glb.clouddn.com/2015/4/24/sleeping-timer_large.png)\n\n这个更接近于MRI中GIL的实现方式。右上角的线程是我们新创建的。由于它是当前唯一要获取GIL的线程，它唤醒了定时器线程。\n\n定时器线程防止GIL被霸占。每100毫秒，定时器线程都给当前占用GIL的线程设定一个中断，通过`RUBY_VM_SET_TIMER_INTERRUPT`宏。这里的细节很重要，应为它会给我们解释`array << nil`是否是原子操作。\n\n如果你熟悉时间片的概念，这个很类似。\n\n每100毫秒定时器线程都会给持有GIL的线程设定一个中断标识。设定中断标志并不是一定要真正中断线程的执行。\n\n## 处理中断标志\n\n在`vm_eval.c`文件中，有Ruby如何调用方法的代码。它负责设定方法调用的上下文环境，并调用正确的方法。在`vm_call0_body`函数最后，在返回函数调用值之前，中断被检查。\n\n```c\nstatic VALUE\nvm_call0_body(rb_thread_t* th, rb_call_info_t *ci, const VALUE *argv)\n{\n  VALUE ret;\n \n  success:\n    RUBY_VM_CHECK_INTS(th);\n  return ret;\n}\n```\n\n如果中断标志已经被设定，那么它在这个店停止执行，在返回函数调用值之前。在执行任何其他Ruby代码之前，当前线程会释放GIL，并调用`sched_yield`方法。`sched_yield`方法是系统方法，用于将线程调度器调度到其他线程上。一旦这个操作完成，被中断的线程尝试重新获取GIL，等待其他线程释放GIL。\n\n好了，这就是我们的答案。`aray << nil`是原子的。感谢GIL，所有的C实现的Ruby方法都是原子操作。\n\n因此这个例子：\n\n```ruby\narray = []\n\n5.times.map do\n  Thread.new do\n    1000.times do\n      array << nil\n    end\n  end\nend.each(&:join)\n\nputs array.size\n```\n\n保证每次在MRI上执行，都会产生正确的结果。\n\n**但是记住这个保证在其他Ruby实现上是没有的。** 如果你将这个代码拿到其他没有GIL的Ruby实现上运行，就会产生一个非预期的结果。知道GIL的保证是好事，不过编写基于GIL的代码不是个好主意。如果你这样做，你的代码就只能在MRI的环境上运行了。\n\n同样的，GIL不是一个公开的API。它没有文档也没有规格。当前有Ruby代码隐式依赖于GIL，但是MRI开发组提到以后会去掉GIL，或者改变它的语义。基于这些原因，你不应该编写基于当前GIL行为的Ruby代码。\n\n## 非原生方法\n\n我倒现在说的都是`array << nil`是原子的。这个很简单，因为`Array#<<`方法获取一个参数为产量值(`nil`)，而且在这个表达式里面只有一个方法调用，用C开发。即使在代码中中断，它也会继续执行到结束，并释放GIL。\n\n那下面的代码呢？\n\n```ruby\narray << User.find(1)\n```\n\n如果`Array#<<`方法能够执行，那么它必须要先计算`User.find(1)`的值。你知道，在Rails中，`User.find(1)`在它的实现里会调用一大堆Ruby代码。\n\n因此，用Ruby代码实现的方法就没有MRI的原子操作保证了。只有用C写的代码才有这个保证。\n\n那么，这是否意味着`Array#<<`在上面的代码中任然是原子的？是的，但是仅限于它右边的值已经被计算过了。换句话说，`User.find(1)`方法调用没有原子性保障。它的执行结果值会作为参数传递给`Array#<<`，而这个操作有原子性保障。\n\n## 这意味着啥？\n\nGIL将方法调用原子化了。这对你意味着啥？\n\n在第一部分中，我给你展示了在一段C函数中间执行时进行上下文切换的情况。有了GIL，这种情况就不可能了。如果线程切换发生了，其他的线程会保持空闲状态等待GIL，让当前的线程有机会不被中断继续执行。这个行为只在MRI中，C编写的Ruby代码才有。\n\n这个行为消除了MRI中很多可能发生的竞争环境。从这个角度来说，GIL是MRI的一个严格内部实现。它保持了MRI的安全性。\n\n但是还有一个问题没有得到回答。GIL是否保证了你编写的所有Ruby代码线程安全？\n\n我们在第三篇里面会回答这个问题。","source":"_posts/ruby_gil.md","raw":"title: Ruby GIL之谜\ndate: 2015/04/18 21:44:00\ncategories:\n  - ruby\ntags:\n  - gil\n  - 并发\n\n---\n> 从[jstorimer](http://www.jstorimer.com/blogs/workingwithcode/8085491-nobody-understands-the-gil)的博客翻译\n\n# Nobody understands the GIL Part1 \n## 什么是GIL\n提起Ruby的多线程，就不得不说Ruby里面的GIL。GIL全称是`Global Interpreter Lock`（全局解释器锁），那么GIL到底是啥呢？\n\n```\nMRI有一个全局的解释器锁。它用于锁住Ruby代码的执行。这意味着在一个多线程环境中，在同一个时间，只有一个线程能够执行Ruby代码。\n```\n\n因此，如果你有8个线程，工作在一个8核的CPU机器上，在任何时间中，只有一个线程能够在其中一个核上运行（不过这个不一定表示每次都运行在同一个核心上）。GIL用于保护Ruby内部，用于防止产生竞争环境(race condition)，进而导致数据损坏。\n\n## 问题\n\n## 往数组中增加数据不是线程安全的\n\n在Ruby中，只有很少的操作默认是线程安全的。比如，往数组中增加元素：\n\n```ruby\narray = []\n\n5.times.map do\n  Thread.new do\n    1000.times do\n      array << nil\n    end\n  end\nend.each(&:join)\n\nputs array.size\n```\n\n这里有5个线程共享1个数组对象。每个线程往数组里面`push`1000次`nil`。所以到最后，数组里面应该有5000个nil，是吧？\n\n```\n$ ruby pushing_nil.rb\n5000\n```\n\n```\n$ jruby pushing_nil.rb\n4446\n```\n\n```\n$ rbx pushing_nil.rb\n3088\n```\n\n这么一个简单地例子，已经暴露出Ruby的一个操作不是线程安全的。在这里到底发生了什么？\n\n<!-- more -->\n\n请注意MRI实现产生了正确的结果 5000 。JRuby和Rubinius产生了错误的结果。如果你重新运行脚本，你可能会发现MRI再一次返回正确结果，但是JRuby和Rubinius产生了不同的错误结果。    \n\n结果不一致的原因就是应为GIL。因为MRI有GIL，虽然说有5个线程都在运行，实际上一次只有一个线程是活动的。换句话说，执行不是并行的。JRuby和Rubinius因为没有GIL，当你有5个线程在运行时，你真的有5个线程同时在所有的CPU核心上运行！\n\n在那些支持并行的Ruby实现上，5个线程都进入运行线程不安全的代码。它们相互影响，最终导致破坏底层数据。\n\n## 多线程如何破坏数据\n\n怎么会这样呢？Ruby不是程序员最好的朋友吗？我会给你展示一些基于高阶解释的技术细节，也会给你展示这个从技术上来说是可能的。\n\n当你使用MRI,JRuby,Rubinius的时候，不同的Ruby实现采用了不同的语言。MRI是C语言写的，JRuby使用Java编写，Rubinius是使用Ruby和C++混合实现的。因此当你有如下的Ruby语句：\n\n```ruby\narray << nil\n```\n\n这条语句会转换为几十上百条底层代码。以MRI的`Array#<<`方法为例：\n\n```c\nVALUE\nrb_ary_push(VALUE ary, VALUE item)\n{\n    long idx = RARRAY_LEN(ary);\n\n    ary_ensure_room_for_push(ary, 1);\n    RARRAY_ASET(ary, idx, item);\n    ARY_SET_LEN(ary, idx + 1);\n    return ary;\n}\n```\n\n请注意：这里至少有 **4条底层操作** 。\n\n1. 获取当前数组的长度。\n2. 检查数组中是否有空间用于插入新数据\n3. 将新数据附加到数组\n4. 设定数组的长度为旧长度+1\n\n每条这种操作又会调用其他函数或者宏。我会将这个的目的是，给你看看多线程是如何损坏数据的。在单线程环境中，你可以看看这段C代码，并且可以很容易地跟踪函数的执行路径。换句话说，我们已经习惯了通过代码以线性的方式，推理整个'世界'的状态。这就是我们通常编写代码的方式。\n\n当涉及多个线程，这不再是可能的了。当有两个线程，每个线程通过代码跟踪其自己的路径。现在，你必须保持2 （或以上）的'指针'，指向每个正在执行的线程。因为线程共享相同的内存空间（同一个进程中），两个线程可同时改变“世界”的状态。\n\n一个线程中断另一个线程的执行，改变了另外一个线程的内部状态，然后另外的线程继续执行，完全不知道的事物的状态发生了变化。这种情况是完全可能的。\n\n这就是为什么一些Ruby实现，往数组中简单地附加数据也会产生错误结果的原因。请看下图：\n\n这里是我们的初始系统状态。\n\n![append_base](http://7vzu7z.com1.z0.glb.clouddn.com/2015/4/19/append_base_grande.png)\n\n这里有两个活动线程，同时进入了这个函数。考虑第1-4步是这个函数(`Array#<<`)实现的伪代码。一旦两个线程都进入这个函数，这里是一个可能出现的执行顺序，以线程A开始。\n\n![append_arrows_grande](http://7vzu7z.com1.z0.glb.clouddn.com/2015/4/19/append_arrows_grande.png)\n\n这个看起来有些复杂，但是只需要跟着箭头指向的顺序来了解这里发生了什么。在每个步骤上，我增加了小标签，用于从每个线程的角度来显示状态变化。\n\n这只是其中一种可能的执行序列。\n\n在此发生的是：线程A开始按顺序路径执行此函数，不过当它执行到第三步的时候，它遇到了上下文切换。因此线程A就在此地方暂停执行。此时线程B开始执行，它执行完整个函数，将元素附加到数组末尾并增加数组长度属性。\n\n一旦线程B执行完成，线程A恢复上下文，从中断的地方继续执行。记住，线程A在增加长度属性之前被暂停，因此它继续执行并增加数组长度。只不过它并不知道线程B在它的眼皮子底下修改了状态。\n\n线程B将长度设置为1，然后线程A将长度设置为1，两个都已经将元素附加到数组末尾。数据就这样被破坏掉了，这个事件顺序就是导致JRuby或者Rubinius结果不正确的原因。\n\n除此之外，在JRuby和Rubinius中，通常还有更为复杂的情况并发执行。在这种情况下，一个线程被暂停后，同时并行运行的其他线程，所有的线程都有可能在同一时间处理数据。\n\n如果你重复执行测试脚本，你会发现不正确的结果每次都不相同。这里线程切换是 **非确定性的，不可预知的** ，它完全有可能发生在函数执行前，执行后，或者没啥关系。\n\n**那为啥Ruby不帮我们搞定这些事情呢？** 其他编程语言的数组同理也不提供线程安全保障：代价太昂贵了。其他Ruby实现要提供线程安全的数据结构是可能的，但是会导致额外的开销，最终导致单线程程序执行变慢。而开发者的责任就是在需要的时候保证线程安全。\n\n那么问题来了，线程安全哪家强？Ruby实现找蓝翔…………\n\n如果这样的线程切换是可能的，那为什么MRI能够输出正确的结果呢？这个线程切换又到底是啥鬼东西？(ˇˍˇ） 想～)\n\n问题1就是我写这篇文章的原因。对于GIL的高阶理解是无法回答这个问题的。高阶理解只能知道一个时间只有一个线程在执行。但是当上下文切换在Ruby函数执行中发生的时候，会发生啥？什么是GIL语义？\n\n但是首先……\n\n## 都是调度器的错！\n\n上下文切换来自于操作系统的线程调度器。在所有的Ruby实现中，一个Ruby线程对应一个操作系统原生线程。操作系统保证没有一个线程会把系统的所有资源（比如CPU时间片）全部吃完，因此操作系统实现了线程的调度器，用于在各个线程中公平分配资源。\n\n这表现为一系列的暂停和恢复。每个线程都有机会用于占用一个时间片资源，然后它被暂停并记录上下文，其他线程就有它们的机会执行。随着时间的推移，这个线程将被恢复执行，如此反复。\n\n这对于操作系统来说是很有效的，不过给你的程序带来了一定程度上的随机性。例如`Array#<<`方法就需要察觉它可能在任何时间被暂停，然后另外的线程并行执行同样的操作，在它的眼皮底下修改'整个世界'的状态。\n\n**怎么办？将操作原子化。**\n\n如果你需要确保操作不被中断，那么需要将操作原子化。如此你就确保在操作完成之前不会被中断。这样就可以防止我们前面例子的第三步，最终当它恢复执行第4步的时候，防止损坏数据。\n\n原子化操作最简单的方式就是使用锁。以下代码确保在MRI，JRuby和Rubinius上都可以输出正确结果。\n\n```ruby\narray = []\nmutex = Mutex.new\n\n5.times.map do\n  Thread.new do\n\n    mutex.synchronize do\n      1000.times do\n        array << nil\n      end\n    end\n\n  end\nend.each(&:join)\n\nputs array.size\n```\n\n这段代码使用了一个共享互斥量或者锁来确保执行结果正确。一旦一个线程进入了`mutex.synchronize`代码块，其他所有线程必须等到当前线程将代码块执行完成后，才能进入同样地代码。通过将操作原子化，你确保了在代码块里即使发生了上下文切换，其他线程也无法进入同样的代码。线程调度器可以看到这个，将调度重新切换到其他线程上。这同时也确保了其他线程无法修改'世界状态'。这就是线程安全。\n\n## GIL也是一把锁\n\n我已经给你展示了如何使用锁来将操作原子化，并提供线程安全保证。GIL也是一个锁，那么它确保了你的所有Ruby代码都是线程安全的吗？它确保`Array#<<`操作原子化吗？\n\n# Nobody understands the GIL Part2\n\n在第一部分我们留下了2个问题:\n\n1. GIL确保`array << nil`是原子操作吗？\n2. GIL确保你的Ruby代码线程安全吗？\n\n第一个操作我们通过查看源代码来解决。\n\n回忆一下上次的代码片段：\n\n```ruby\narray = []\n\n5.times.map do\n  Thread.new do\n    1000.times do\n      array << nil\n    end\n  end\nend.each(&:join)\n\nputs array.size\n```\n\n如果你假设数组是线程安全的，那么期望的结果应该是5000。但是由于数组不是线程安全的，因此JRuby和Rubinius产生了一个非预期的结果--小于5000。这就是多个线程的上下文切换导致损坏数据的原因。\n\n**MRI产生了预期结果，但它是侥幸还是担保呢？** 我们通过查看Ruby的源代码片段来学习：\n\n```ruby\nThread.new do\n  array << nil\nend\n```\n\n## 从头说起\n\n要知道这段代码内部发生了啥，我们需要看看MRI是如何启动线程的。我们会查看MRI源代码的[thread.c](https://github.com/ruby/ruby/blob/trunk/thread.c)文件。\n\n第一段开始的代码`Thread.new`是启动了一个原生线程来支撑ruby线程。启动线程的函数是`thread_start_func_2`。我们从大的方向来看看这个函数。\n\n```c\nstatic int\nthread_start_func_2(rb_thread_t *th, VALUE *stack_start, VALUE *register_stack_start)\n{\n    int state;\n    VALUE args = th->first_args;\n    rb_proc_t *proc;\n    rb_thread_list_t *join_list;\n    rb_thread_t *main_th;\n    VALUE errinfo = Qnil;\n    if (th == th->vm->main_thread)\n  \n    ruby_thread_set_native(th);\n\n    th->machine.stack_start = stack_start;\n    thread_debug(\"thread start: %p\\n\", (void *)th);\n\n    gvl_acquire(th->vm, th);    // **获取GIL锁**\n    {\n      thread_debug(\"thread start (get lock): %p\\n\", (void *)th);\n      rb_thread_set_current(th);    // **设定当前线程**\n\n      TH_PUSH_TAG(th);\n      if ((state = EXEC_TAG()) == 0) {\n          SAVE_ROOT_JMPBUF(th, {\n                    native_set_thread_name(th);\n        if (!th->first_func) {\n            GetProcPtr(th->first_proc, proc);\n            th->errinfo = Qnil;\n            th->root_lep = rb_vm_ep_local_ep(proc->block.ep);\n            th->root_svar = Qnil;\n            EXEC_EVENT_HOOK(th, RUBY_EVENT_THREAD_BEGIN, th->self, 0, 0, Qundef);\n            th->value = rb_vm_invoke_proc(th, proc, (int)RARRAY_LEN(args), RARRAY_CONST_PTR(args), 0);  // 执行线程代码块\n            EXEC_EVENT_HOOK(th, RUBY_EVENT_THREAD_END, th->self, 0, 0, Qundef);\n        }\n        else {\n            th->value = (*th->first_func)((void *)args);\n        }\n          });\n      }\n      else {\n        ...\n      }\n\n      th->status = THREAD_KILLED;\n      thread_debug(\"thread end: %p\\n\", (void *)th);\n\n      main_th = th->vm->main_thread;\n      if (main_th == th) {\n          ruby_stop(0);\n      }\n      if (RB_TYPE_P(errinfo, T_OBJECT)) {\n          /* treat with normal error object */\n          rb_threadptr_raise(main_th, 1, &errinfo);\n      }\n      TH_POP_TAG();\n\n      /* locking_mutex must be Qfalse */\n      if (th->locking_mutex != Qfalse) {\n          rb_bug(\"thread_start_func_2: locking_mutex must not be set (%p:%\"PRIxVALUE\")\",\n           (void *)th, th->locking_mutex);\n      }\n\n      /* delete self other than main thread from living_threads */\n      rb_vm_living_threads_remove(th->vm, th);\n      if (rb_thread_alone()) {\n          /* I'm last thread. wake up main thread from rb_thread_terminate_all */\n          rb_threadptr_interrupt(main_th);\n      }\n\n      /* wake up joining threads */\n      join_list = th->join_list;\n      while (join_list) {\n          rb_threadptr_interrupt(join_list->th);\n          switch (join_list->th->status) {\n            case THREAD_STOPPED: case THREAD_STOPPED_FOREVER:\n        join_list->th->status = THREAD_RUNNABLE;\n            default: break;\n          }\n          join_list = join_list->next;\n      }\n\n      rb_threadptr_unlock_all_locking_mutexes(th);\n      rb_check_deadlock(th->vm);\n\n      if (!th->root_fiber) {\n          rb_thread_recycle_stack_release(th->stack);\n          th->stack = 0;\n      }\n    }\n    native_mutex_lock(&th->vm->thread_destruct_lock);\n    /* make sure vm->running_thread never point me after this point.*/\n    th->vm->running_thread = NULL;\n    native_mutex_unlock(&th->vm->thread_destruct_lock);\n    thread_cleanup_func(th, FALSE);\n    gvl_release(th->vm);  // **释放GIL**\n\n    return 0;\n}\n```\n \n这个函数中有很多代码，不过我们着重看加了注释的部分。在顶部，这个新线程会获取GIL。记住，这个线程在实际拿到GIL之前，都是空闲的。在代码中间，它调用你传给线程的代码块。在完成这些之后，它释放GIL并退出原生线程。\n\n在我们的代码片段里，这个新线程是由主线程启动的。基于这个情况，我们可以假设主线程当前持有GIL。在主线程释放GIL之前，这个新线程只能等待。\n\n我们看看当这个新线程想要获取GIL时发生了啥(Linux平台)：\n\n```c\nstatic void\ngvl_acquire_common(rb_vm_t *vm)\n{\n    if (vm->gvl.acquired) {\n        vm->gvl.waiting++;\n        if (vm->gvl.waiting == 1) {\n            /*\n             * Wake up timer thread iff timer thread is slept.\n             * When timer thread is polling mode, we don't want to\n             * make confusing timer thread interval time.\n             */\n            rb_thread_wakeup_timer_thread_low();\n        }\n\n        while (vm->gvl.acquired) {\n            native_cond_wait(&vm->gvl.cond, &vm->gvl.lock);\n        }\n\n        vm->gvl.waiting--;\n\n        if (vm->gvl.need_yield) {\n            vm->gvl.need_yield = 0;\n            native_cond_signal(&vm->gvl.switch_cond);\n        }\n    }\n\n    vm->gvl.acquired = 1;\n}\n```\n\n\n这个是Linux平台上的`gvl_acquire_common`函数。这个函数被`gvl_acquire`函数调用，用于获取GIL。\n\n首先它检查当前是否已经获取了GIL。如果是，那么就增加GIL的waiting属性。对于我们的执行代码来说，这个值现在应该是1。下面的代码用于检查等待值是否为1.如果是，下一行代码就触发定时器线程的唤醒。\n\n定时器线程是MRI的秘密武器，用于MRI线程系统的顺畅，并防止任何一个线程长时间占用GIL。但在此之前，我们不要跑那么快，先让说明GIL的一些信息，再介绍该定时器线程。\n\n![pre-gil_2_medium](http://7vzu7z.com1.z0.glb.clouddn.com/2015/4/24/pre-gil_2_medium.png)\n我已经说过，MRI线程对应一个原生操作系统线程。但是这张图表示每个MRI线程是在它的原生线程上并行执行的。GIL防止了这个。我们需要将GIL加入到图中，将图标变得更为现实。\n\n![with-gil_medium](http://7vzu7z.com1.z0.glb.clouddn.com/2015/4/24/with-gil_medium.png)\n\n当Ruby线程想在它的原生线程里面执行代码时，它必须要首先获取GIL。**GIL作为Ruby线程和底层原生线程的中间者，严重降低了并行！在前一张图中，多个Ruby线程和其底层的原生线程都是并行执行的。第二张图更接近于MRI，在任何时间，只有一个线程能够获取到GIL，因此MRI中并行执行代码完全被禁止。\n\n**根据MRI开发组成员的说法，GIL保护了系统内部状态。** 由于有GIL，它们不需要显示获取锁，或者对内部数据进行同步。如果两个线程无法同时修改内部状态，那么就不存在竞争环境。\n\n对于开发者，这会严重限制你的代码在MRI上无法并行执行。\n\n## 定时器线程\n\n我已经说过了，定时器线程是用于防止其他线程霸占GIL的。定时器线程是MRI的一个内部原生线程，它没有关联的Ruby线程。定时器线程由MRI函数`rb_thread_create_timer_thread`方法启动。\n\n当MRI启动后只有主线程在运行时，定时器线程处于睡眠状态。但记住，一旦一个线程开始等待GIL，它就唤醒定时器线程。\n\n![sleeping-timer_large](http://7vzu7z.com1.z0.glb.clouddn.com/2015/4/24/sleeping-timer_large.png)\n\n这个更接近于MRI中GIL的实现方式。右上角的线程是我们新创建的。由于它是当前唯一要获取GIL的线程，它唤醒了定时器线程。\n\n定时器线程防止GIL被霸占。每100毫秒，定时器线程都给当前占用GIL的线程设定一个中断，通过`RUBY_VM_SET_TIMER_INTERRUPT`宏。这里的细节很重要，应为它会给我们解释`array << nil`是否是原子操作。\n\n如果你熟悉时间片的概念，这个很类似。\n\n每100毫秒定时器线程都会给持有GIL的线程设定一个中断标识。设定中断标志并不是一定要真正中断线程的执行。\n\n## 处理中断标志\n\n在`vm_eval.c`文件中，有Ruby如何调用方法的代码。它负责设定方法调用的上下文环境，并调用正确的方法。在`vm_call0_body`函数最后，在返回函数调用值之前，中断被检查。\n\n```c\nstatic VALUE\nvm_call0_body(rb_thread_t* th, rb_call_info_t *ci, const VALUE *argv)\n{\n  VALUE ret;\n \n  success:\n    RUBY_VM_CHECK_INTS(th);\n  return ret;\n}\n```\n\n如果中断标志已经被设定，那么它在这个店停止执行，在返回函数调用值之前。在执行任何其他Ruby代码之前，当前线程会释放GIL，并调用`sched_yield`方法。`sched_yield`方法是系统方法，用于将线程调度器调度到其他线程上。一旦这个操作完成，被中断的线程尝试重新获取GIL，等待其他线程释放GIL。\n\n好了，这就是我们的答案。`aray << nil`是原子的。感谢GIL，所有的C实现的Ruby方法都是原子操作。\n\n因此这个例子：\n\n```ruby\narray = []\n\n5.times.map do\n  Thread.new do\n    1000.times do\n      array << nil\n    end\n  end\nend.each(&:join)\n\nputs array.size\n```\n\n保证每次在MRI上执行，都会产生正确的结果。\n\n**但是记住这个保证在其他Ruby实现上是没有的。** 如果你将这个代码拿到其他没有GIL的Ruby实现上运行，就会产生一个非预期的结果。知道GIL的保证是好事，不过编写基于GIL的代码不是个好主意。如果你这样做，你的代码就只能在MRI的环境上运行了。\n\n同样的，GIL不是一个公开的API。它没有文档也没有规格。当前有Ruby代码隐式依赖于GIL，但是MRI开发组提到以后会去掉GIL，或者改变它的语义。基于这些原因，你不应该编写基于当前GIL行为的Ruby代码。\n\n## 非原生方法\n\n我倒现在说的都是`array << nil`是原子的。这个很简单，因为`Array#<<`方法获取一个参数为产量值(`nil`)，而且在这个表达式里面只有一个方法调用，用C开发。即使在代码中中断，它也会继续执行到结束，并释放GIL。\n\n那下面的代码呢？\n\n```ruby\narray << User.find(1)\n```\n\n如果`Array#<<`方法能够执行，那么它必须要先计算`User.find(1)`的值。你知道，在Rails中，`User.find(1)`在它的实现里会调用一大堆Ruby代码。\n\n因此，用Ruby代码实现的方法就没有MRI的原子操作保证了。只有用C写的代码才有这个保证。\n\n那么，这是否意味着`Array#<<`在上面的代码中任然是原子的？是的，但是仅限于它右边的值已经被计算过了。换句话说，`User.find(1)`方法调用没有原子性保障。它的执行结果值会作为参数传递给`Array#<<`，而这个操作有原子性保障。\n\n## 这意味着啥？\n\nGIL将方法调用原子化了。这对你意味着啥？\n\n在第一部分中，我给你展示了在一段C函数中间执行时进行上下文切换的情况。有了GIL，这种情况就不可能了。如果线程切换发生了，其他的线程会保持空闲状态等待GIL，让当前的线程有机会不被中断继续执行。这个行为只在MRI中，C编写的Ruby代码才有。\n\n这个行为消除了MRI中很多可能发生的竞争环境。从这个角度来说，GIL是MRI的一个严格内部实现。它保持了MRI的安全性。\n\n但是还有一个问题没有得到回答。GIL是否保证了你编写的所有Ruby代码线程安全？\n\n我们在第三篇里面会回答这个问题。","slug":"ruby_gil","published":1,"updated":"2016-12-14T14:53:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizij4bip0002p6ddo321jfip","content":"<blockquote>\n<p>从<a href=\"http://www.jstorimer.com/blogs/workingwithcode/8085491-nobody-understands-the-gil\" target=\"_blank\" rel=\"external\">jstorimer</a>的博客翻译</p>\n</blockquote>\n<h1 id=\"Nobody-understands-the-GIL-Part1\"><a href=\"#Nobody-understands-the-GIL-Part1\" class=\"headerlink\" title=\"Nobody understands the GIL Part1\"></a>Nobody understands the GIL Part1</h1><h2 id=\"什么是GIL\"><a href=\"#什么是GIL\" class=\"headerlink\" title=\"什么是GIL\"></a>什么是GIL</h2><p>提起Ruby的多线程，就不得不说Ruby里面的GIL。GIL全称是<code>Global Interpreter Lock</code>（全局解释器锁），那么GIL到底是啥呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">MRI有一个全局的解释器锁。它用于锁住Ruby代码的执行。这意味着在一个多线程环境中，在同一个时间，只有一个线程能够执行Ruby代码。</div></pre></td></tr></table></figure>\n<p>因此，如果你有8个线程，工作在一个8核的CPU机器上，在任何时间中，只有一个线程能够在其中一个核上运行（不过这个不一定表示每次都运行在同一个核心上）。GIL用于保护Ruby内部，用于防止产生竞争环境(race condition)，进而导致数据损坏。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><h2 id=\"往数组中增加数据不是线程安全的\"><a href=\"#往数组中增加数据不是线程安全的\" class=\"headerlink\" title=\"往数组中增加数据不是线程安全的\"></a>往数组中增加数据不是线程安全的</h2><p>在Ruby中，只有很少的操作默认是线程安全的。比如，往数组中增加元素：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">array = []</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">5</span>.times.map <span class=\"keyword\">do</span></div><div class=\"line\">  Thread.new <span class=\"keyword\">do</span></div><div class=\"line\">    <span class=\"number\">1000</span>.times <span class=\"keyword\">do</span></div><div class=\"line\">      array &lt;&lt; <span class=\"literal\">nil</span></div><div class=\"line\">    <span class=\"keyword\">end</span></div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span>.each(&amp;<span class=\"symbol\">:join</span>)</div><div class=\"line\"></div><div class=\"line\">puts array.size</div></pre></td></tr></table></figure>\n<p>这里有5个线程共享1个数组对象。每个线程往数组里面<code>push</code>1000次<code>nil</code>。所以到最后，数组里面应该有5000个nil，是吧？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ruby pushing_nil.rb</div><div class=\"line\">5000</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ jruby pushing_nil.rb</div><div class=\"line\">4446</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ rbx pushing_nil.rb</div><div class=\"line\">3088</div></pre></td></tr></table></figure>\n<p>这么一个简单地例子，已经暴露出Ruby的一个操作不是线程安全的。在这里到底发生了什么？</p>\n<a id=\"more\"></a>\n<p>请注意MRI实现产生了正确的结果 5000 。JRuby和Rubinius产生了错误的结果。如果你重新运行脚本，你可能会发现MRI再一次返回正确结果，但是JRuby和Rubinius产生了不同的错误结果。    </p>\n<p>结果不一致的原因就是应为GIL。因为MRI有GIL，虽然说有5个线程都在运行，实际上一次只有一个线程是活动的。换句话说，执行不是并行的。JRuby和Rubinius因为没有GIL，当你有5个线程在运行时，你真的有5个线程同时在所有的CPU核心上运行！</p>\n<p>在那些支持并行的Ruby实现上，5个线程都进入运行线程不安全的代码。它们相互影响，最终导致破坏底层数据。</p>\n<h2 id=\"多线程如何破坏数据\"><a href=\"#多线程如何破坏数据\" class=\"headerlink\" title=\"多线程如何破坏数据\"></a>多线程如何破坏数据</h2><p>怎么会这样呢？Ruby不是程序员最好的朋友吗？我会给你展示一些基于高阶解释的技术细节，也会给你展示这个从技术上来说是可能的。</p>\n<p>当你使用MRI,JRuby,Rubinius的时候，不同的Ruby实现采用了不同的语言。MRI是C语言写的，JRuby使用Java编写，Rubinius是使用Ruby和C++混合实现的。因此当你有如下的Ruby语句：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">array &lt;&lt; <span class=\"literal\">nil</span></div></pre></td></tr></table></figure>\n<p>这条语句会转换为几十上百条底层代码。以MRI的<code>Array#&lt;&lt;</code>方法为例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">VALUE</span></div><div class=\"line\"><span class=\"title\">rb_ary_push</span><span class=\"params\">(VALUE ary, VALUE item)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">long</span> idx = RARRAY_LEN(ary);</div><div class=\"line\"></div><div class=\"line\">    ary_ensure_room_for_push(ary, <span class=\"number\">1</span>);</div><div class=\"line\">    RARRAY_ASET(ary, idx, item);</div><div class=\"line\">    ARY_SET_LEN(ary, idx + <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> ary;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>请注意：这里至少有 <strong>4条底层操作</strong> 。</p>\n<ol>\n<li>获取当前数组的长度。</li>\n<li>检查数组中是否有空间用于插入新数据</li>\n<li>将新数据附加到数组</li>\n<li>设定数组的长度为旧长度+1</li>\n</ol>\n<p>每条这种操作又会调用其他函数或者宏。我会将这个的目的是，给你看看多线程是如何损坏数据的。在单线程环境中，你可以看看这段C代码，并且可以很容易地跟踪函数的执行路径。换句话说，我们已经习惯了通过代码以线性的方式，推理整个’世界’的状态。这就是我们通常编写代码的方式。</p>\n<p>当涉及多个线程，这不再是可能的了。当有两个线程，每个线程通过代码跟踪其自己的路径。现在，你必须保持2 （或以上）的’指针’，指向每个正在执行的线程。因为线程共享相同的内存空间（同一个进程中），两个线程可同时改变“世界”的状态。</p>\n<p>一个线程中断另一个线程的执行，改变了另外一个线程的内部状态，然后另外的线程继续执行，完全不知道的事物的状态发生了变化。这种情况是完全可能的。</p>\n<p>这就是为什么一些Ruby实现，往数组中简单地附加数据也会产生错误结果的原因。请看下图：</p>\n<p>这里是我们的初始系统状态。</p>\n<p><img src=\"http://7vzu7z.com1.z0.glb.clouddn.com/2015/4/19/append_base_grande.png\" alt=\"append_base\"></p>\n<p>这里有两个活动线程，同时进入了这个函数。考虑第1-4步是这个函数(<code>Array#&lt;&lt;</code>)实现的伪代码。一旦两个线程都进入这个函数，这里是一个可能出现的执行顺序，以线程A开始。</p>\n<p><img src=\"http://7vzu7z.com1.z0.glb.clouddn.com/2015/4/19/append_arrows_grande.png\" alt=\"append_arrows_grande\"></p>\n<p>这个看起来有些复杂，但是只需要跟着箭头指向的顺序来了解这里发生了什么。在每个步骤上，我增加了小标签，用于从每个线程的角度来显示状态变化。</p>\n<p>这只是其中一种可能的执行序列。</p>\n<p>在此发生的是：线程A开始按顺序路径执行此函数，不过当它执行到第三步的时候，它遇到了上下文切换。因此线程A就在此地方暂停执行。此时线程B开始执行，它执行完整个函数，将元素附加到数组末尾并增加数组长度属性。</p>\n<p>一旦线程B执行完成，线程A恢复上下文，从中断的地方继续执行。记住，线程A在增加长度属性之前被暂停，因此它继续执行并增加数组长度。只不过它并不知道线程B在它的眼皮子底下修改了状态。</p>\n<p>线程B将长度设置为1，然后线程A将长度设置为1，两个都已经将元素附加到数组末尾。数据就这样被破坏掉了，这个事件顺序就是导致JRuby或者Rubinius结果不正确的原因。</p>\n<p>除此之外，在JRuby和Rubinius中，通常还有更为复杂的情况并发执行。在这种情况下，一个线程被暂停后，同时并行运行的其他线程，所有的线程都有可能在同一时间处理数据。</p>\n<p>如果你重复执行测试脚本，你会发现不正确的结果每次都不相同。这里线程切换是 <strong>非确定性的，不可预知的</strong> ，它完全有可能发生在函数执行前，执行后，或者没啥关系。</p>\n<p><strong>那为啥Ruby不帮我们搞定这些事情呢？</strong> 其他编程语言的数组同理也不提供线程安全保障：代价太昂贵了。其他Ruby实现要提供线程安全的数据结构是可能的，但是会导致额外的开销，最终导致单线程程序执行变慢。而开发者的责任就是在需要的时候保证线程安全。</p>\n<p>那么问题来了，线程安全哪家强？Ruby实现找蓝翔…………</p>\n<p>如果这样的线程切换是可能的，那为什么MRI能够输出正确的结果呢？这个线程切换又到底是啥鬼东西？(ˇˍˇ） 想～)</p>\n<p>问题1就是我写这篇文章的原因。对于GIL的高阶理解是无法回答这个问题的。高阶理解只能知道一个时间只有一个线程在执行。但是当上下文切换在Ruby函数执行中发生的时候，会发生啥？什么是GIL语义？</p>\n<p>但是首先……</p>\n<h2 id=\"都是调度器的错！\"><a href=\"#都是调度器的错！\" class=\"headerlink\" title=\"都是调度器的错！\"></a>都是调度器的错！</h2><p>上下文切换来自于操作系统的线程调度器。在所有的Ruby实现中，一个Ruby线程对应一个操作系统原生线程。操作系统保证没有一个线程会把系统的所有资源（比如CPU时间片）全部吃完，因此操作系统实现了线程的调度器，用于在各个线程中公平分配资源。</p>\n<p>这表现为一系列的暂停和恢复。每个线程都有机会用于占用一个时间片资源，然后它被暂停并记录上下文，其他线程就有它们的机会执行。随着时间的推移，这个线程将被恢复执行，如此反复。</p>\n<p>这对于操作系统来说是很有效的，不过给你的程序带来了一定程度上的随机性。例如<code>Array#&lt;&lt;</code>方法就需要察觉它可能在任何时间被暂停，然后另外的线程并行执行同样的操作，在它的眼皮底下修改’整个世界’的状态。</p>\n<p><strong>怎么办？将操作原子化。</strong></p>\n<p>如果你需要确保操作不被中断，那么需要将操作原子化。如此你就确保在操作完成之前不会被中断。这样就可以防止我们前面例子的第三步，最终当它恢复执行第4步的时候，防止损坏数据。</p>\n<p>原子化操作最简单的方式就是使用锁。以下代码确保在MRI，JRuby和Rubinius上都可以输出正确结果。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">array = []</div><div class=\"line\">mutex = Mutex.new</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">5</span>.times.map <span class=\"keyword\">do</span></div><div class=\"line\">  Thread.new <span class=\"keyword\">do</span></div><div class=\"line\"></div><div class=\"line\">    mutex.synchronize <span class=\"keyword\">do</span></div><div class=\"line\">      <span class=\"number\">1000</span>.times <span class=\"keyword\">do</span></div><div class=\"line\">        array &lt;&lt; <span class=\"literal\">nil</span></div><div class=\"line\">      <span class=\"keyword\">end</span></div><div class=\"line\">    <span class=\"keyword\">end</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span>.each(&amp;<span class=\"symbol\">:join</span>)</div><div class=\"line\"></div><div class=\"line\">puts array.size</div></pre></td></tr></table></figure>\n<p>这段代码使用了一个共享互斥量或者锁来确保执行结果正确。一旦一个线程进入了<code>mutex.synchronize</code>代码块，其他所有线程必须等到当前线程将代码块执行完成后，才能进入同样地代码。通过将操作原子化，你确保了在代码块里即使发生了上下文切换，其他线程也无法进入同样的代码。线程调度器可以看到这个，将调度重新切换到其他线程上。这同时也确保了其他线程无法修改’世界状态’。这就是线程安全。</p>\n<h2 id=\"GIL也是一把锁\"><a href=\"#GIL也是一把锁\" class=\"headerlink\" title=\"GIL也是一把锁\"></a>GIL也是一把锁</h2><p>我已经给你展示了如何使用锁来将操作原子化，并提供线程安全保证。GIL也是一个锁，那么它确保了你的所有Ruby代码都是线程安全的吗？它确保<code>Array#&lt;&lt;</code>操作原子化吗？</p>\n<h1 id=\"Nobody-understands-the-GIL-Part2\"><a href=\"#Nobody-understands-the-GIL-Part2\" class=\"headerlink\" title=\"Nobody understands the GIL Part2\"></a>Nobody understands the GIL Part2</h1><p>在第一部分我们留下了2个问题:</p>\n<ol>\n<li>GIL确保<code>array &lt;&lt; nil</code>是原子操作吗？</li>\n<li>GIL确保你的Ruby代码线程安全吗？</li>\n</ol>\n<p>第一个操作我们通过查看源代码来解决。</p>\n<p>回忆一下上次的代码片段：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">array = []</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">5</span>.times.map <span class=\"keyword\">do</span></div><div class=\"line\">  Thread.new <span class=\"keyword\">do</span></div><div class=\"line\">    <span class=\"number\">1000</span>.times <span class=\"keyword\">do</span></div><div class=\"line\">      array &lt;&lt; <span class=\"literal\">nil</span></div><div class=\"line\">    <span class=\"keyword\">end</span></div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span>.each(&amp;<span class=\"symbol\">:join</span>)</div><div class=\"line\"></div><div class=\"line\">puts array.size</div></pre></td></tr></table></figure>\n<p>如果你假设数组是线程安全的，那么期望的结果应该是5000。但是由于数组不是线程安全的，因此JRuby和Rubinius产生了一个非预期的结果–小于5000。这就是多个线程的上下文切换导致损坏数据的原因。</p>\n<p><strong>MRI产生了预期结果，但它是侥幸还是担保呢？</strong> 我们通过查看Ruby的源代码片段来学习：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread.new <span class=\"keyword\">do</span></div><div class=\"line\">  array &lt;&lt; <span class=\"literal\">nil</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<h2 id=\"从头说起\"><a href=\"#从头说起\" class=\"headerlink\" title=\"从头说起\"></a>从头说起</h2><p>要知道这段代码内部发生了啥，我们需要看看MRI是如何启动线程的。我们会查看MRI源代码的<a href=\"https://github.com/ruby/ruby/blob/trunk/thread.c\" target=\"_blank\" rel=\"external\">thread.c</a>文件。</p>\n<p>第一段开始的代码<code>Thread.new</code>是启动了一个原生线程来支撑ruby线程。启动线程的函数是<code>thread_start_func_2</code>。我们从大的方向来看看这个函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">thread_start_func_2</span><span class=\"params\">(<span class=\"keyword\">rb_thread_t</span> *th, VALUE *stack_start, VALUE *register_stack_start)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> state;</div><div class=\"line\">    VALUE args = th-&gt;first_args;</div><div class=\"line\">    <span class=\"keyword\">rb_proc_t</span> *proc;</div><div class=\"line\">    <span class=\"keyword\">rb_thread_list_t</span> *join_list;</div><div class=\"line\">    <span class=\"keyword\">rb_thread_t</span> *main_th;</div><div class=\"line\">    VALUE errinfo = Qnil;</div><div class=\"line\">    <span class=\"keyword\">if</span> (th == th-&gt;vm-&gt;main_thread)</div><div class=\"line\">  </div><div class=\"line\">    ruby_thread_set_native(th);</div><div class=\"line\"></div><div class=\"line\">    th-&gt;machine.stack_start = stack_start;</div><div class=\"line\">    thread_debug(<span class=\"string\">\"thread start: %p\\n\"</span>, (<span class=\"keyword\">void</span> *)th);</div><div class=\"line\"></div><div class=\"line\">    gvl_acquire(th-&gt;vm, th);    <span class=\"comment\">// **获取GIL锁**</span></div><div class=\"line\">    &#123;</div><div class=\"line\">      thread_debug(<span class=\"string\">\"thread start (get lock): %p\\n\"</span>, (<span class=\"keyword\">void</span> *)th);</div><div class=\"line\">      rb_thread_set_current(th);    <span class=\"comment\">// **设定当前线程**</span></div><div class=\"line\"></div><div class=\"line\">      TH_PUSH_TAG(th);</div><div class=\"line\">      <span class=\"keyword\">if</span> ((state = EXEC_TAG()) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">          SAVE_ROOT_JMPBUF(th, &#123;</div><div class=\"line\">                    native_set_thread_name(th);</div><div class=\"line\">        <span class=\"keyword\">if</span> (!th-&gt;first_func) &#123;</div><div class=\"line\">            GetProcPtr(th-&gt;first_proc, proc);</div><div class=\"line\">            th-&gt;errinfo = Qnil;</div><div class=\"line\">            th-&gt;root_lep = rb_vm_ep_local_ep(proc-&gt;block.ep);</div><div class=\"line\">            th-&gt;root_svar = Qnil;</div><div class=\"line\">            EXEC_EVENT_HOOK(th, RUBY_EVENT_THREAD_BEGIN, th-&gt;self, <span class=\"number\">0</span>, <span class=\"number\">0</span>, Qundef);</div><div class=\"line\">            th-&gt;value = rb_vm_invoke_proc(th, proc, (<span class=\"keyword\">int</span>)RARRAY_LEN(args), RARRAY_CONST_PTR(args), <span class=\"number\">0</span>);  <span class=\"comment\">// 执行线程代码块</span></div><div class=\"line\">            EXEC_EVENT_HOOK(th, RUBY_EVENT_THREAD_END, th-&gt;self, <span class=\"number\">0</span>, <span class=\"number\">0</span>, Qundef);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            th-&gt;value = (*th-&gt;first_func)((<span class=\"keyword\">void</span> *)args);</div><div class=\"line\">        &#125;</div><div class=\"line\">          &#125;);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        ...</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      th-&gt;status = THREAD_KILLED;</div><div class=\"line\">      thread_debug(<span class=\"string\">\"thread end: %p\\n\"</span>, (<span class=\"keyword\">void</span> *)th);</div><div class=\"line\"></div><div class=\"line\">      main_th = th-&gt;vm-&gt;main_thread;</div><div class=\"line\">      <span class=\"keyword\">if</span> (main_th == th) &#123;</div><div class=\"line\">          ruby_stop(<span class=\"number\">0</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (RB_TYPE_P(errinfo, T_OBJECT)) &#123;</div><div class=\"line\">          <span class=\"comment\">/* treat with normal error object */</span></div><div class=\"line\">          rb_threadptr_raise(main_th, <span class=\"number\">1</span>, &amp;errinfo);</div><div class=\"line\">      &#125;</div><div class=\"line\">      TH_POP_TAG();</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">/* locking_mutex must be Qfalse */</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (th-&gt;locking_mutex != Qfalse) &#123;</div><div class=\"line\">          rb_bug(<span class=\"string\">\"thread_start_func_2: locking_mutex must not be set (%p:%\"</span>PRIxVALUE<span class=\"string\">\")\"</span>,</div><div class=\"line\">           (<span class=\"keyword\">void</span> *)th, th-&gt;locking_mutex);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">/* delete self other than main thread from living_threads */</span></div><div class=\"line\">      rb_vm_living_threads_remove(th-&gt;vm, th);</div><div class=\"line\">      <span class=\"keyword\">if</span> (rb_thread_alone()) &#123;</div><div class=\"line\">          <span class=\"comment\">/* I'm last thread. wake up main thread from rb_thread_terminate_all */</span></div><div class=\"line\">          rb_threadptr_interrupt(main_th);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">/* wake up joining threads */</span></div><div class=\"line\">      join_list = th-&gt;join_list;</div><div class=\"line\">      <span class=\"keyword\">while</span> (join_list) &#123;</div><div class=\"line\">          rb_threadptr_interrupt(join_list-&gt;th);</div><div class=\"line\">          <span class=\"keyword\">switch</span> (join_list-&gt;th-&gt;status) &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> THREAD_STOPPED: <span class=\"keyword\">case</span> THREAD_STOPPED_FOREVER:</div><div class=\"line\">        join_list-&gt;th-&gt;status = THREAD_RUNNABLE;</div><div class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">break</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">          join_list = join_list-&gt;next;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      rb_threadptr_unlock_all_locking_mutexes(th);</div><div class=\"line\">      rb_check_deadlock(th-&gt;vm);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (!th-&gt;root_fiber) &#123;</div><div class=\"line\">          rb_thread_recycle_stack_release(th-&gt;<span class=\"built_in\">stack</span>);</div><div class=\"line\">          th-&gt;<span class=\"built_in\">stack</span> = <span class=\"number\">0</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    native_mutex_lock(&amp;th-&gt;vm-&gt;thread_destruct_lock);</div><div class=\"line\">    <span class=\"comment\">/* make sure vm-&gt;running_thread never point me after this point.*/</span></div><div class=\"line\">    th-&gt;vm-&gt;running_thread = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    native_mutex_unlock(&amp;th-&gt;vm-&gt;thread_destruct_lock);</div><div class=\"line\">    thread_cleanup_func(th, FALSE);</div><div class=\"line\">    gvl_release(th-&gt;vm);  <span class=\"comment\">// **释放GIL**</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个函数中有很多代码，不过我们着重看加了注释的部分。在顶部，这个新线程会获取GIL。记住，这个线程在实际拿到GIL之前，都是空闲的。在代码中间，它调用你传给线程的代码块。在完成这些之后，它释放GIL并退出原生线程。</p>\n<p>在我们的代码片段里，这个新线程是由主线程启动的。基于这个情况，我们可以假设主线程当前持有GIL。在主线程释放GIL之前，这个新线程只能等待。</p>\n<p>我们看看当这个新线程想要获取GIL时发生了啥(Linux平台)：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">gvl_acquire_common</span><span class=\"params\">(<span class=\"keyword\">rb_vm_t</span> *vm)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (vm-&gt;gvl.acquired) &#123;</div><div class=\"line\">        vm-&gt;gvl.waiting++;</div><div class=\"line\">        <span class=\"keyword\">if</span> (vm-&gt;gvl.waiting == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">/*</span></div><div class=\"line\">             * Wake up timer thread iff timer thread is slept.</div><div class=\"line\">             * When timer thread is polling mode, we don't want to</div><div class=\"line\">             * make confusing timer thread interval time.</div><div class=\"line\">             */</div><div class=\"line\">            rb_thread_wakeup_timer_thread_low();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">while</span> (vm-&gt;gvl.acquired) &#123;</div><div class=\"line\">            native_cond_wait(&amp;vm-&gt;gvl.cond, &amp;vm-&gt;gvl.lock);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        vm-&gt;gvl.waiting--;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (vm-&gt;gvl.need_yield) &#123;</div><div class=\"line\">            vm-&gt;gvl.need_yield = <span class=\"number\">0</span>;</div><div class=\"line\">            native_cond_signal(&amp;vm-&gt;gvl.switch_cond);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    vm-&gt;gvl.acquired = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个是Linux平台上的<code>gvl_acquire_common</code>函数。这个函数被<code>gvl_acquire</code>函数调用，用于获取GIL。</p>\n<p>首先它检查当前是否已经获取了GIL。如果是，那么就增加GIL的waiting属性。对于我们的执行代码来说，这个值现在应该是1。下面的代码用于检查等待值是否为1.如果是，下一行代码就触发定时器线程的唤醒。</p>\n<p>定时器线程是MRI的秘密武器，用于MRI线程系统的顺畅，并防止任何一个线程长时间占用GIL。但在此之前，我们不要跑那么快，先让说明GIL的一些信息，再介绍该定时器线程。</p>\n<p><img src=\"http://7vzu7z.com1.z0.glb.clouddn.com/2015/4/24/pre-gil_2_medium.png\" alt=\"pre-gil_2_medium\"><br>我已经说过，MRI线程对应一个原生操作系统线程。但是这张图表示每个MRI线程是在它的原生线程上并行执行的。GIL防止了这个。我们需要将GIL加入到图中，将图标变得更为现实。</p>\n<p><img src=\"http://7vzu7z.com1.z0.glb.clouddn.com/2015/4/24/with-gil_medium.png\" alt=\"with-gil_medium\"></p>\n<p>当Ruby线程想在它的原生线程里面执行代码时，它必须要首先获取GIL。**GIL作为Ruby线程和底层原生线程的中间者，严重降低了并行！在前一张图中，多个Ruby线程和其底层的原生线程都是并行执行的。第二张图更接近于MRI，在任何时间，只有一个线程能够获取到GIL，因此MRI中并行执行代码完全被禁止。</p>\n<p><strong>根据MRI开发组成员的说法，GIL保护了系统内部状态。</strong> 由于有GIL，它们不需要显示获取锁，或者对内部数据进行同步。如果两个线程无法同时修改内部状态，那么就不存在竞争环境。</p>\n<p>对于开发者，这会严重限制你的代码在MRI上无法并行执行。</p>\n<h2 id=\"定时器线程\"><a href=\"#定时器线程\" class=\"headerlink\" title=\"定时器线程\"></a>定时器线程</h2><p>我已经说过了，定时器线程是用于防止其他线程霸占GIL的。定时器线程是MRI的一个内部原生线程，它没有关联的Ruby线程。定时器线程由MRI函数<code>rb_thread_create_timer_thread</code>方法启动。</p>\n<p>当MRI启动后只有主线程在运行时，定时器线程处于睡眠状态。但记住，一旦一个线程开始等待GIL，它就唤醒定时器线程。</p>\n<p><img src=\"http://7vzu7z.com1.z0.glb.clouddn.com/2015/4/24/sleeping-timer_large.png\" alt=\"sleeping-timer_large\"></p>\n<p>这个更接近于MRI中GIL的实现方式。右上角的线程是我们新创建的。由于它是当前唯一要获取GIL的线程，它唤醒了定时器线程。</p>\n<p>定时器线程防止GIL被霸占。每100毫秒，定时器线程都给当前占用GIL的线程设定一个中断，通过<code>RUBY_VM_SET_TIMER_INTERRUPT</code>宏。这里的细节很重要，应为它会给我们解释<code>array &lt;&lt; nil</code>是否是原子操作。</p>\n<p>如果你熟悉时间片的概念，这个很类似。</p>\n<p>每100毫秒定时器线程都会给持有GIL的线程设定一个中断标识。设定中断标志并不是一定要真正中断线程的执行。</p>\n<h2 id=\"处理中断标志\"><a href=\"#处理中断标志\" class=\"headerlink\" title=\"处理中断标志\"></a>处理中断标志</h2><p>在<code>vm_eval.c</code>文件中，有Ruby如何调用方法的代码。它负责设定方法调用的上下文环境，并调用正确的方法。在<code>vm_call0_body</code>函数最后，在返回函数调用值之前，中断被检查。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> VALUE</span></div><div class=\"line\"><span class=\"title\">vm_call0_body</span><span class=\"params\">(<span class=\"keyword\">rb_thread_t</span>* th, <span class=\"keyword\">rb_call_info_t</span> *ci, <span class=\"keyword\">const</span> VALUE *argv)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  VALUE ret;</div><div class=\"line\"> </div><div class=\"line\">  success:</div><div class=\"line\">    RUBY_VM_CHECK_INTS(th);</div><div class=\"line\">  <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果中断标志已经被设定，那么它在这个店停止执行，在返回函数调用值之前。在执行任何其他Ruby代码之前，当前线程会释放GIL，并调用<code>sched_yield</code>方法。<code>sched_yield</code>方法是系统方法，用于将线程调度器调度到其他线程上。一旦这个操作完成，被中断的线程尝试重新获取GIL，等待其他线程释放GIL。</p>\n<p>好了，这就是我们的答案。<code>aray &lt;&lt; nil</code>是原子的。感谢GIL，所有的C实现的Ruby方法都是原子操作。</p>\n<p>因此这个例子：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">array = []</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">5</span>.times.map <span class=\"keyword\">do</span></div><div class=\"line\">  Thread.new <span class=\"keyword\">do</span></div><div class=\"line\">    <span class=\"number\">1000</span>.times <span class=\"keyword\">do</span></div><div class=\"line\">      array &lt;&lt; <span class=\"literal\">nil</span></div><div class=\"line\">    <span class=\"keyword\">end</span></div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span>.each(&amp;<span class=\"symbol\">:join</span>)</div><div class=\"line\"></div><div class=\"line\">puts array.size</div></pre></td></tr></table></figure>\n<p>保证每次在MRI上执行，都会产生正确的结果。</p>\n<p><strong>但是记住这个保证在其他Ruby实现上是没有的。</strong> 如果你将这个代码拿到其他没有GIL的Ruby实现上运行，就会产生一个非预期的结果。知道GIL的保证是好事，不过编写基于GIL的代码不是个好主意。如果你这样做，你的代码就只能在MRI的环境上运行了。</p>\n<p>同样的，GIL不是一个公开的API。它没有文档也没有规格。当前有Ruby代码隐式依赖于GIL，但是MRI开发组提到以后会去掉GIL，或者改变它的语义。基于这些原因，你不应该编写基于当前GIL行为的Ruby代码。</p>\n<h2 id=\"非原生方法\"><a href=\"#非原生方法\" class=\"headerlink\" title=\"非原生方法\"></a>非原生方法</h2><p>我倒现在说的都是<code>array &lt;&lt; nil</code>是原子的。这个很简单，因为<code>Array#&lt;&lt;</code>方法获取一个参数为产量值(<code>nil</code>)，而且在这个表达式里面只有一个方法调用，用C开发。即使在代码中中断，它也会继续执行到结束，并释放GIL。</p>\n<p>那下面的代码呢？</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">array &lt;&lt; User.find(<span class=\"number\">1</span>)</div></pre></td></tr></table></figure>\n<p>如果<code>Array#&lt;&lt;</code>方法能够执行，那么它必须要先计算<code>User.find(1)</code>的值。你知道，在Rails中，<code>User.find(1)</code>在它的实现里会调用一大堆Ruby代码。</p>\n<p>因此，用Ruby代码实现的方法就没有MRI的原子操作保证了。只有用C写的代码才有这个保证。</p>\n<p>那么，这是否意味着<code>Array#&lt;&lt;</code>在上面的代码中任然是原子的？是的，但是仅限于它右边的值已经被计算过了。换句话说，<code>User.find(1)</code>方法调用没有原子性保障。它的执行结果值会作为参数传递给<code>Array#&lt;&lt;</code>，而这个操作有原子性保障。</p>\n<h2 id=\"这意味着啥？\"><a href=\"#这意味着啥？\" class=\"headerlink\" title=\"这意味着啥？\"></a>这意味着啥？</h2><p>GIL将方法调用原子化了。这对你意味着啥？</p>\n<p>在第一部分中，我给你展示了在一段C函数中间执行时进行上下文切换的情况。有了GIL，这种情况就不可能了。如果线程切换发生了，其他的线程会保持空闲状态等待GIL，让当前的线程有机会不被中断继续执行。这个行为只在MRI中，C编写的Ruby代码才有。</p>\n<p>这个行为消除了MRI中很多可能发生的竞争环境。从这个角度来说，GIL是MRI的一个严格内部实现。它保持了MRI的安全性。</p>\n<p>但是还有一个问题没有得到回答。GIL是否保证了你编写的所有Ruby代码线程安全？</p>\n<p>我们在第三篇里面会回答这个问题。</p>\n","excerpt":"<blockquote>\n<p>从<a href=\"http://www.jstorimer.com/blogs/workingwithcode/8085491-nobody-understands-the-gil\">jstorimer</a>的博客翻译</p>\n</blockquote>\n<h1 id=\"Nobody-understands-the-GIL-Part1\"><a href=\"#Nobody-understands-the-GIL-Part1\" class=\"headerlink\" title=\"Nobody understands the GIL Part1\"></a>Nobody understands the GIL Part1</h1><h2 id=\"什么是GIL\"><a href=\"#什么是GIL\" class=\"headerlink\" title=\"什么是GIL\"></a>什么是GIL</h2><p>提起Ruby的多线程，就不得不说Ruby里面的GIL。GIL全称是<code>Global Interpreter Lock</code>（全局解释器锁），那么GIL到底是啥呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">MRI有一个全局的解释器锁。它用于锁住Ruby代码的执行。这意味着在一个多线程环境中，在同一个时间，只有一个线程能够执行Ruby代码。</div></pre></td></tr></table></figure>\n<p>因此，如果你有8个线程，工作在一个8核的CPU机器上，在任何时间中，只有一个线程能够在其中一个核上运行（不过这个不一定表示每次都运行在同一个核心上）。GIL用于保护Ruby内部，用于防止产生竞争环境(race condition)，进而导致数据损坏。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><h2 id=\"往数组中增加数据不是线程安全的\"><a href=\"#往数组中增加数据不是线程安全的\" class=\"headerlink\" title=\"往数组中增加数据不是线程安全的\"></a>往数组中增加数据不是线程安全的</h2><p>在Ruby中，只有很少的操作默认是线程安全的。比如，往数组中增加元素：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">array = []</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">5</span>.times.map <span class=\"keyword\">do</span></div><div class=\"line\">  Thread.new <span class=\"keyword\">do</span></div><div class=\"line\">    <span class=\"number\">1000</span>.times <span class=\"keyword\">do</span></div><div class=\"line\">      array &lt;&lt; <span class=\"literal\">nil</span></div><div class=\"line\">    <span class=\"keyword\">end</span></div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span>.each(&amp;<span class=\"symbol\">:join</span>)</div><div class=\"line\"></div><div class=\"line\">puts array.size</div></pre></td></tr></table></figure>\n<p>这里有5个线程共享1个数组对象。每个线程往数组里面<code>push</code>1000次<code>nil</code>。所以到最后，数组里面应该有5000个nil，是吧？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ruby pushing_nil.rb</div><div class=\"line\">5000</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ jruby pushing_nil.rb</div><div class=\"line\">4446</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ rbx pushing_nil.rb</div><div class=\"line\">3088</div></pre></td></tr></table></figure>\n<p>这么一个简单地例子，已经暴露出Ruby的一个操作不是线程安全的。在这里到底发生了什么？</p>","more":"<p>请注意MRI实现产生了正确的结果 5000 。JRuby和Rubinius产生了错误的结果。如果你重新运行脚本，你可能会发现MRI再一次返回正确结果，但是JRuby和Rubinius产生了不同的错误结果。    </p>\n<p>结果不一致的原因就是应为GIL。因为MRI有GIL，虽然说有5个线程都在运行，实际上一次只有一个线程是活动的。换句话说，执行不是并行的。JRuby和Rubinius因为没有GIL，当你有5个线程在运行时，你真的有5个线程同时在所有的CPU核心上运行！</p>\n<p>在那些支持并行的Ruby实现上，5个线程都进入运行线程不安全的代码。它们相互影响，最终导致破坏底层数据。</p>\n<h2 id=\"多线程如何破坏数据\"><a href=\"#多线程如何破坏数据\" class=\"headerlink\" title=\"多线程如何破坏数据\"></a>多线程如何破坏数据</h2><p>怎么会这样呢？Ruby不是程序员最好的朋友吗？我会给你展示一些基于高阶解释的技术细节，也会给你展示这个从技术上来说是可能的。</p>\n<p>当你使用MRI,JRuby,Rubinius的时候，不同的Ruby实现采用了不同的语言。MRI是C语言写的，JRuby使用Java编写，Rubinius是使用Ruby和C++混合实现的。因此当你有如下的Ruby语句：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">array &lt;&lt; <span class=\"literal\">nil</span></div></pre></td></tr></table></figure>\n<p>这条语句会转换为几十上百条底层代码。以MRI的<code>Array#&lt;&lt;</code>方法为例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">VALUE</div><div class=\"line\"><span class=\"title\">rb_ary_push</span><span class=\"params\">(VALUE ary, VALUE item)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">long</span> idx = RARRAY_LEN(ary);</div><div class=\"line\"></div><div class=\"line\">    ary_ensure_room_for_push(ary, <span class=\"number\">1</span>);</div><div class=\"line\">    RARRAY_ASET(ary, idx, item);</div><div class=\"line\">    ARY_SET_LEN(ary, idx + <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> ary;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>请注意：这里至少有 <strong>4条底层操作</strong> 。</p>\n<ol>\n<li>获取当前数组的长度。</li>\n<li>检查数组中是否有空间用于插入新数据</li>\n<li>将新数据附加到数组</li>\n<li>设定数组的长度为旧长度+1</li>\n</ol>\n<p>每条这种操作又会调用其他函数或者宏。我会将这个的目的是，给你看看多线程是如何损坏数据的。在单线程环境中，你可以看看这段C代码，并且可以很容易地跟踪函数的执行路径。换句话说，我们已经习惯了通过代码以线性的方式，推理整个’世界’的状态。这就是我们通常编写代码的方式。</p>\n<p>当涉及多个线程，这不再是可能的了。当有两个线程，每个线程通过代码跟踪其自己的路径。现在，你必须保持2 （或以上）的’指针’，指向每个正在执行的线程。因为线程共享相同的内存空间（同一个进程中），两个线程可同时改变“世界”的状态。</p>\n<p>一个线程中断另一个线程的执行，改变了另外一个线程的内部状态，然后另外的线程继续执行，完全不知道的事物的状态发生了变化。这种情况是完全可能的。</p>\n<p>这就是为什么一些Ruby实现，往数组中简单地附加数据也会产生错误结果的原因。请看下图：</p>\n<p>这里是我们的初始系统状态。</p>\n<p><img src=\"http://7vzu7z.com1.z0.glb.clouddn.com/2015/4/19/append_base_grande.png\" alt=\"append_base\"></p>\n<p>这里有两个活动线程，同时进入了这个函数。考虑第1-4步是这个函数(<code>Array#&lt;&lt;</code>)实现的伪代码。一旦两个线程都进入这个函数，这里是一个可能出现的执行顺序，以线程A开始。</p>\n<p><img src=\"http://7vzu7z.com1.z0.glb.clouddn.com/2015/4/19/append_arrows_grande.png\" alt=\"append_arrows_grande\"></p>\n<p>这个看起来有些复杂，但是只需要跟着箭头指向的顺序来了解这里发生了什么。在每个步骤上，我增加了小标签，用于从每个线程的角度来显示状态变化。</p>\n<p>这只是其中一种可能的执行序列。</p>\n<p>在此发生的是：线程A开始按顺序路径执行此函数，不过当它执行到第三步的时候，它遇到了上下文切换。因此线程A就在此地方暂停执行。此时线程B开始执行，它执行完整个函数，将元素附加到数组末尾并增加数组长度属性。</p>\n<p>一旦线程B执行完成，线程A恢复上下文，从中断的地方继续执行。记住，线程A在增加长度属性之前被暂停，因此它继续执行并增加数组长度。只不过它并不知道线程B在它的眼皮子底下修改了状态。</p>\n<p>线程B将长度设置为1，然后线程A将长度设置为1，两个都已经将元素附加到数组末尾。数据就这样被破坏掉了，这个事件顺序就是导致JRuby或者Rubinius结果不正确的原因。</p>\n<p>除此之外，在JRuby和Rubinius中，通常还有更为复杂的情况并发执行。在这种情况下，一个线程被暂停后，同时并行运行的其他线程，所有的线程都有可能在同一时间处理数据。</p>\n<p>如果你重复执行测试脚本，你会发现不正确的结果每次都不相同。这里线程切换是 <strong>非确定性的，不可预知的</strong> ，它完全有可能发生在函数执行前，执行后，或者没啥关系。</p>\n<p><strong>那为啥Ruby不帮我们搞定这些事情呢？</strong> 其他编程语言的数组同理也不提供线程安全保障：代价太昂贵了。其他Ruby实现要提供线程安全的数据结构是可能的，但是会导致额外的开销，最终导致单线程程序执行变慢。而开发者的责任就是在需要的时候保证线程安全。</p>\n<p>那么问题来了，线程安全哪家强？Ruby实现找蓝翔…………</p>\n<p>如果这样的线程切换是可能的，那为什么MRI能够输出正确的结果呢？这个线程切换又到底是啥鬼东西？(ˇˍˇ） 想～)</p>\n<p>问题1就是我写这篇文章的原因。对于GIL的高阶理解是无法回答这个问题的。高阶理解只能知道一个时间只有一个线程在执行。但是当上下文切换在Ruby函数执行中发生的时候，会发生啥？什么是GIL语义？</p>\n<p>但是首先……</p>\n<h2 id=\"都是调度器的错！\"><a href=\"#都是调度器的错！\" class=\"headerlink\" title=\"都是调度器的错！\"></a>都是调度器的错！</h2><p>上下文切换来自于操作系统的线程调度器。在所有的Ruby实现中，一个Ruby线程对应一个操作系统原生线程。操作系统保证没有一个线程会把系统的所有资源（比如CPU时间片）全部吃完，因此操作系统实现了线程的调度器，用于在各个线程中公平分配资源。</p>\n<p>这表现为一系列的暂停和恢复。每个线程都有机会用于占用一个时间片资源，然后它被暂停并记录上下文，其他线程就有它们的机会执行。随着时间的推移，这个线程将被恢复执行，如此反复。</p>\n<p>这对于操作系统来说是很有效的，不过给你的程序带来了一定程度上的随机性。例如<code>Array#&lt;&lt;</code>方法就需要察觉它可能在任何时间被暂停，然后另外的线程并行执行同样的操作，在它的眼皮底下修改’整个世界’的状态。</p>\n<p><strong>怎么办？将操作原子化。</strong></p>\n<p>如果你需要确保操作不被中断，那么需要将操作原子化。如此你就确保在操作完成之前不会被中断。这样就可以防止我们前面例子的第三步，最终当它恢复执行第4步的时候，防止损坏数据。</p>\n<p>原子化操作最简单的方式就是使用锁。以下代码确保在MRI，JRuby和Rubinius上都可以输出正确结果。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">array = []</div><div class=\"line\">mutex = Mutex.new</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">5</span>.times.map <span class=\"keyword\">do</span></div><div class=\"line\">  Thread.new <span class=\"keyword\">do</span></div><div class=\"line\"></div><div class=\"line\">    mutex.synchronize <span class=\"keyword\">do</span></div><div class=\"line\">      <span class=\"number\">1000</span>.times <span class=\"keyword\">do</span></div><div class=\"line\">        array &lt;&lt; <span class=\"literal\">nil</span></div><div class=\"line\">      <span class=\"keyword\">end</span></div><div class=\"line\">    <span class=\"keyword\">end</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span>.each(&amp;<span class=\"symbol\">:join</span>)</div><div class=\"line\"></div><div class=\"line\">puts array.size</div></pre></td></tr></table></figure>\n<p>这段代码使用了一个共享互斥量或者锁来确保执行结果正确。一旦一个线程进入了<code>mutex.synchronize</code>代码块，其他所有线程必须等到当前线程将代码块执行完成后，才能进入同样地代码。通过将操作原子化，你确保了在代码块里即使发生了上下文切换，其他线程也无法进入同样的代码。线程调度器可以看到这个，将调度重新切换到其他线程上。这同时也确保了其他线程无法修改’世界状态’。这就是线程安全。</p>\n<h2 id=\"GIL也是一把锁\"><a href=\"#GIL也是一把锁\" class=\"headerlink\" title=\"GIL也是一把锁\"></a>GIL也是一把锁</h2><p>我已经给你展示了如何使用锁来将操作原子化，并提供线程安全保证。GIL也是一个锁，那么它确保了你的所有Ruby代码都是线程安全的吗？它确保<code>Array#&lt;&lt;</code>操作原子化吗？</p>\n<h1 id=\"Nobody-understands-the-GIL-Part2\"><a href=\"#Nobody-understands-the-GIL-Part2\" class=\"headerlink\" title=\"Nobody understands the GIL Part2\"></a>Nobody understands the GIL Part2</h1><p>在第一部分我们留下了2个问题:</p>\n<ol>\n<li>GIL确保<code>array &lt;&lt; nil</code>是原子操作吗？</li>\n<li>GIL确保你的Ruby代码线程安全吗？</li>\n</ol>\n<p>第一个操作我们通过查看源代码来解决。</p>\n<p>回忆一下上次的代码片段：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">array = []</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">5</span>.times.map <span class=\"keyword\">do</span></div><div class=\"line\">  Thread.new <span class=\"keyword\">do</span></div><div class=\"line\">    <span class=\"number\">1000</span>.times <span class=\"keyword\">do</span></div><div class=\"line\">      array &lt;&lt; <span class=\"literal\">nil</span></div><div class=\"line\">    <span class=\"keyword\">end</span></div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span>.each(&amp;<span class=\"symbol\">:join</span>)</div><div class=\"line\"></div><div class=\"line\">puts array.size</div></pre></td></tr></table></figure>\n<p>如果你假设数组是线程安全的，那么期望的结果应该是5000。但是由于数组不是线程安全的，因此JRuby和Rubinius产生了一个非预期的结果–小于5000。这就是多个线程的上下文切换导致损坏数据的原因。</p>\n<p><strong>MRI产生了预期结果，但它是侥幸还是担保呢？</strong> 我们通过查看Ruby的源代码片段来学习：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread.new <span class=\"keyword\">do</span></div><div class=\"line\">  array &lt;&lt; <span class=\"literal\">nil</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<h2 id=\"从头说起\"><a href=\"#从头说起\" class=\"headerlink\" title=\"从头说起\"></a>从头说起</h2><p>要知道这段代码内部发生了啥，我们需要看看MRI是如何启动线程的。我们会查看MRI源代码的<a href=\"https://github.com/ruby/ruby/blob/trunk/thread.c\">thread.c</a>文件。</p>\n<p>第一段开始的代码<code>Thread.new</code>是启动了一个原生线程来支撑ruby线程。启动线程的函数是<code>thread_start_func_2</code>。我们从大的方向来看看这个函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></div><div class=\"line\"><span class=\"title\">thread_start_func_2</span><span class=\"params\">(<span class=\"keyword\">rb_thread_t</span> *th, VALUE *stack_start, VALUE *register_stack_start)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> state;</div><div class=\"line\">    VALUE args = th-&gt;first_args;</div><div class=\"line\">    <span class=\"keyword\">rb_proc_t</span> *proc;</div><div class=\"line\">    <span class=\"keyword\">rb_thread_list_t</span> *join_list;</div><div class=\"line\">    <span class=\"keyword\">rb_thread_t</span> *main_th;</div><div class=\"line\">    VALUE errinfo = Qnil;</div><div class=\"line\">    <span class=\"keyword\">if</span> (th == th-&gt;vm-&gt;main_thread)</div><div class=\"line\">  </div><div class=\"line\">    ruby_thread_set_native(th);</div><div class=\"line\"></div><div class=\"line\">    th-&gt;machine.stack_start = stack_start;</div><div class=\"line\">    thread_debug(<span class=\"string\">\"thread start: %p\\n\"</span>, (<span class=\"keyword\">void</span> *)th);</div><div class=\"line\"></div><div class=\"line\">    gvl_acquire(th-&gt;vm, th);    <span class=\"comment\">// **获取GIL锁**</span></div><div class=\"line\">    &#123;</div><div class=\"line\">      thread_debug(<span class=\"string\">\"thread start (get lock): %p\\n\"</span>, (<span class=\"keyword\">void</span> *)th);</div><div class=\"line\">      rb_thread_set_current(th);    <span class=\"comment\">// **设定当前线程**</span></div><div class=\"line\"></div><div class=\"line\">      TH_PUSH_TAG(th);</div><div class=\"line\">      <span class=\"keyword\">if</span> ((state = EXEC_TAG()) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">          SAVE_ROOT_JMPBUF(th, &#123;</div><div class=\"line\">                    native_set_thread_name(th);</div><div class=\"line\">        <span class=\"keyword\">if</span> (!th-&gt;first_func) &#123;</div><div class=\"line\">            GetProcPtr(th-&gt;first_proc, proc);</div><div class=\"line\">            th-&gt;errinfo = Qnil;</div><div class=\"line\">            th-&gt;root_lep = rb_vm_ep_local_ep(proc-&gt;block.ep);</div><div class=\"line\">            th-&gt;root_svar = Qnil;</div><div class=\"line\">            EXEC_EVENT_HOOK(th, RUBY_EVENT_THREAD_BEGIN, th-&gt;self, <span class=\"number\">0</span>, <span class=\"number\">0</span>, Qundef);</div><div class=\"line\">            th-&gt;value = rb_vm_invoke_proc(th, proc, (<span class=\"keyword\">int</span>)RARRAY_LEN(args), RARRAY_CONST_PTR(args), <span class=\"number\">0</span>);  <span class=\"comment\">// 执行线程代码块</span></div><div class=\"line\">            EXEC_EVENT_HOOK(th, RUBY_EVENT_THREAD_END, th-&gt;self, <span class=\"number\">0</span>, <span class=\"number\">0</span>, Qundef);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            th-&gt;value = (*th-&gt;first_func)((<span class=\"keyword\">void</span> *)args);</div><div class=\"line\">        &#125;</div><div class=\"line\">          &#125;);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        ...</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      th-&gt;status = THREAD_KILLED;</div><div class=\"line\">      thread_debug(<span class=\"string\">\"thread end: %p\\n\"</span>, (<span class=\"keyword\">void</span> *)th);</div><div class=\"line\"></div><div class=\"line\">      main_th = th-&gt;vm-&gt;main_thread;</div><div class=\"line\">      <span class=\"keyword\">if</span> (main_th == th) &#123;</div><div class=\"line\">          ruby_stop(<span class=\"number\">0</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (RB_TYPE_P(errinfo, T_OBJECT)) &#123;</div><div class=\"line\">          <span class=\"comment\">/* treat with normal error object */</span></div><div class=\"line\">          rb_threadptr_raise(main_th, <span class=\"number\">1</span>, &amp;errinfo);</div><div class=\"line\">      &#125;</div><div class=\"line\">      TH_POP_TAG();</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">/* locking_mutex must be Qfalse */</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (th-&gt;locking_mutex != Qfalse) &#123;</div><div class=\"line\">          rb_bug(<span class=\"string\">\"thread_start_func_2: locking_mutex must not be set (%p:%\"</span>PRIxVALUE<span class=\"string\">\")\"</span>,</div><div class=\"line\">           (<span class=\"keyword\">void</span> *)th, th-&gt;locking_mutex);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">/* delete self other than main thread from living_threads */</span></div><div class=\"line\">      rb_vm_living_threads_remove(th-&gt;vm, th);</div><div class=\"line\">      <span class=\"keyword\">if</span> (rb_thread_alone()) &#123;</div><div class=\"line\">          <span class=\"comment\">/* I'm last thread. wake up main thread from rb_thread_terminate_all */</span></div><div class=\"line\">          rb_threadptr_interrupt(main_th);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">/* wake up joining threads */</span></div><div class=\"line\">      join_list = th-&gt;join_list;</div><div class=\"line\">      <span class=\"keyword\">while</span> (join_list) &#123;</div><div class=\"line\">          rb_threadptr_interrupt(join_list-&gt;th);</div><div class=\"line\">          <span class=\"keyword\">switch</span> (join_list-&gt;th-&gt;status) &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> THREAD_STOPPED: <span class=\"keyword\">case</span> THREAD_STOPPED_FOREVER:</div><div class=\"line\">        join_list-&gt;th-&gt;status = THREAD_RUNNABLE;</div><div class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">break</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">          join_list = join_list-&gt;next;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      rb_threadptr_unlock_all_locking_mutexes(th);</div><div class=\"line\">      rb_check_deadlock(th-&gt;vm);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (!th-&gt;root_fiber) &#123;</div><div class=\"line\">          rb_thread_recycle_stack_release(th-&gt;<span class=\"built_in\">stack</span>);</div><div class=\"line\">          th-&gt;<span class=\"built_in\">stack</span> = <span class=\"number\">0</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    native_mutex_lock(&amp;th-&gt;vm-&gt;thread_destruct_lock);</div><div class=\"line\">    <span class=\"comment\">/* make sure vm-&gt;running_thread never point me after this point.*/</span></div><div class=\"line\">    th-&gt;vm-&gt;running_thread = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    native_mutex_unlock(&amp;th-&gt;vm-&gt;thread_destruct_lock);</div><div class=\"line\">    thread_cleanup_func(th, FALSE);</div><div class=\"line\">    gvl_release(th-&gt;vm);  <span class=\"comment\">// **释放GIL**</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个函数中有很多代码，不过我们着重看加了注释的部分。在顶部，这个新线程会获取GIL。记住，这个线程在实际拿到GIL之前，都是空闲的。在代码中间，它调用你传给线程的代码块。在完成这些之后，它释放GIL并退出原生线程。</p>\n<p>在我们的代码片段里，这个新线程是由主线程启动的。基于这个情况，我们可以假设主线程当前持有GIL。在主线程释放GIL之前，这个新线程只能等待。</p>\n<p>我们看看当这个新线程想要获取GIL时发生了啥(Linux平台)：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></div><div class=\"line\"><span class=\"title\">gvl_acquire_common</span><span class=\"params\">(<span class=\"keyword\">rb_vm_t</span> *vm)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (vm-&gt;gvl.acquired) &#123;</div><div class=\"line\">        vm-&gt;gvl.waiting++;</div><div class=\"line\">        <span class=\"keyword\">if</span> (vm-&gt;gvl.waiting == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">/*</div><div class=\"line\">             * Wake up timer thread iff timer thread is slept.</div><div class=\"line\">             * When timer thread is polling mode, we don't want to</div><div class=\"line\">             * make confusing timer thread interval time.</div><div class=\"line\">             */</span></div><div class=\"line\">            rb_thread_wakeup_timer_thread_low();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">while</span> (vm-&gt;gvl.acquired) &#123;</div><div class=\"line\">            native_cond_wait(&amp;vm-&gt;gvl.cond, &amp;vm-&gt;gvl.lock);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        vm-&gt;gvl.waiting--;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (vm-&gt;gvl.need_yield) &#123;</div><div class=\"line\">            vm-&gt;gvl.need_yield = <span class=\"number\">0</span>;</div><div class=\"line\">            native_cond_signal(&amp;vm-&gt;gvl.switch_cond);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    vm-&gt;gvl.acquired = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个是Linux平台上的<code>gvl_acquire_common</code>函数。这个函数被<code>gvl_acquire</code>函数调用，用于获取GIL。</p>\n<p>首先它检查当前是否已经获取了GIL。如果是，那么就增加GIL的waiting属性。对于我们的执行代码来说，这个值现在应该是1。下面的代码用于检查等待值是否为1.如果是，下一行代码就触发定时器线程的唤醒。</p>\n<p>定时器线程是MRI的秘密武器，用于MRI线程系统的顺畅，并防止任何一个线程长时间占用GIL。但在此之前，我们不要跑那么快，先让说明GIL的一些信息，再介绍该定时器线程。</p>\n<p><img src=\"http://7vzu7z.com1.z0.glb.clouddn.com/2015/4/24/pre-gil_2_medium.png\" alt=\"pre-gil_2_medium\"><br>我已经说过，MRI线程对应一个原生操作系统线程。但是这张图表示每个MRI线程是在它的原生线程上并行执行的。GIL防止了这个。我们需要将GIL加入到图中，将图标变得更为现实。</p>\n<p><img src=\"http://7vzu7z.com1.z0.glb.clouddn.com/2015/4/24/with-gil_medium.png\" alt=\"with-gil_medium\"></p>\n<p>当Ruby线程想在它的原生线程里面执行代码时，它必须要首先获取GIL。**GIL作为Ruby线程和底层原生线程的中间者，严重降低了并行！在前一张图中，多个Ruby线程和其底层的原生线程都是并行执行的。第二张图更接近于MRI，在任何时间，只有一个线程能够获取到GIL，因此MRI中并行执行代码完全被禁止。</p>\n<p><strong>根据MRI开发组成员的说法，GIL保护了系统内部状态。</strong> 由于有GIL，它们不需要显示获取锁，或者对内部数据进行同步。如果两个线程无法同时修改内部状态，那么就不存在竞争环境。</p>\n<p>对于开发者，这会严重限制你的代码在MRI上无法并行执行。</p>\n<h2 id=\"定时器线程\"><a href=\"#定时器线程\" class=\"headerlink\" title=\"定时器线程\"></a>定时器线程</h2><p>我已经说过了，定时器线程是用于防止其他线程霸占GIL的。定时器线程是MRI的一个内部原生线程，它没有关联的Ruby线程。定时器线程由MRI函数<code>rb_thread_create_timer_thread</code>方法启动。</p>\n<p>当MRI启动后只有主线程在运行时，定时器线程处于睡眠状态。但记住，一旦一个线程开始等待GIL，它就唤醒定时器线程。</p>\n<p><img src=\"http://7vzu7z.com1.z0.glb.clouddn.com/2015/4/24/sleeping-timer_large.png\" alt=\"sleeping-timer_large\"></p>\n<p>这个更接近于MRI中GIL的实现方式。右上角的线程是我们新创建的。由于它是当前唯一要获取GIL的线程，它唤醒了定时器线程。</p>\n<p>定时器线程防止GIL被霸占。每100毫秒，定时器线程都给当前占用GIL的线程设定一个中断，通过<code>RUBY_VM_SET_TIMER_INTERRUPT</code>宏。这里的细节很重要，应为它会给我们解释<code>array &lt;&lt; nil</code>是否是原子操作。</p>\n<p>如果你熟悉时间片的概念，这个很类似。</p>\n<p>每100毫秒定时器线程都会给持有GIL的线程设定一个中断标识。设定中断标志并不是一定要真正中断线程的执行。</p>\n<h2 id=\"处理中断标志\"><a href=\"#处理中断标志\" class=\"headerlink\" title=\"处理中断标志\"></a>处理中断标志</h2><p>在<code>vm_eval.c</code>文件中，有Ruby如何调用方法的代码。它负责设定方法调用的上下文环境，并调用正确的方法。在<code>vm_call0_body</code>函数最后，在返回函数调用值之前，中断被检查。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> VALUE</div><div class=\"line\"><span class=\"title\">vm_call0_body</span><span class=\"params\">(<span class=\"keyword\">rb_thread_t</span>* th, <span class=\"keyword\">rb_call_info_t</span> *ci, <span class=\"keyword\">const</span> VALUE *argv)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">  VALUE ret;</div><div class=\"line\"> </div><div class=\"line\">  success:</div><div class=\"line\">    RUBY_VM_CHECK_INTS(th);</div><div class=\"line\">  <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果中断标志已经被设定，那么它在这个店停止执行，在返回函数调用值之前。在执行任何其他Ruby代码之前，当前线程会释放GIL，并调用<code>sched_yield</code>方法。<code>sched_yield</code>方法是系统方法，用于将线程调度器调度到其他线程上。一旦这个操作完成，被中断的线程尝试重新获取GIL，等待其他线程释放GIL。</p>\n<p>好了，这就是我们的答案。<code>aray &lt;&lt; nil</code>是原子的。感谢GIL，所有的C实现的Ruby方法都是原子操作。</p>\n<p>因此这个例子：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">array = []</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">5</span>.times.map <span class=\"keyword\">do</span></div><div class=\"line\">  Thread.new <span class=\"keyword\">do</span></div><div class=\"line\">    <span class=\"number\">1000</span>.times <span class=\"keyword\">do</span></div><div class=\"line\">      array &lt;&lt; <span class=\"literal\">nil</span></div><div class=\"line\">    <span class=\"keyword\">end</span></div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span>.each(&amp;<span class=\"symbol\">:join</span>)</div><div class=\"line\"></div><div class=\"line\">puts array.size</div></pre></td></tr></table></figure>\n<p>保证每次在MRI上执行，都会产生正确的结果。</p>\n<p><strong>但是记住这个保证在其他Ruby实现上是没有的。</strong> 如果你将这个代码拿到其他没有GIL的Ruby实现上运行，就会产生一个非预期的结果。知道GIL的保证是好事，不过编写基于GIL的代码不是个好主意。如果你这样做，你的代码就只能在MRI的环境上运行了。</p>\n<p>同样的，GIL不是一个公开的API。它没有文档也没有规格。当前有Ruby代码隐式依赖于GIL，但是MRI开发组提到以后会去掉GIL，或者改变它的语义。基于这些原因，你不应该编写基于当前GIL行为的Ruby代码。</p>\n<h2 id=\"非原生方法\"><a href=\"#非原生方法\" class=\"headerlink\" title=\"非原生方法\"></a>非原生方法</h2><p>我倒现在说的都是<code>array &lt;&lt; nil</code>是原子的。这个很简单，因为<code>Array#&lt;&lt;</code>方法获取一个参数为产量值(<code>nil</code>)，而且在这个表达式里面只有一个方法调用，用C开发。即使在代码中中断，它也会继续执行到结束，并释放GIL。</p>\n<p>那下面的代码呢？</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">array &lt;&lt; User.find(<span class=\"number\">1</span>)</div></pre></td></tr></table></figure>\n<p>如果<code>Array#&lt;&lt;</code>方法能够执行，那么它必须要先计算<code>User.find(1)</code>的值。你知道，在Rails中，<code>User.find(1)</code>在它的实现里会调用一大堆Ruby代码。</p>\n<p>因此，用Ruby代码实现的方法就没有MRI的原子操作保证了。只有用C写的代码才有这个保证。</p>\n<p>那么，这是否意味着<code>Array#&lt;&lt;</code>在上面的代码中任然是原子的？是的，但是仅限于它右边的值已经被计算过了。换句话说，<code>User.find(1)</code>方法调用没有原子性保障。它的执行结果值会作为参数传递给<code>Array#&lt;&lt;</code>，而这个操作有原子性保障。</p>\n<h2 id=\"这意味着啥？\"><a href=\"#这意味着啥？\" class=\"headerlink\" title=\"这意味着啥？\"></a>这意味着啥？</h2><p>GIL将方法调用原子化了。这对你意味着啥？</p>\n<p>在第一部分中，我给你展示了在一段C函数中间执行时进行上下文切换的情况。有了GIL，这种情况就不可能了。如果线程切换发生了，其他的线程会保持空闲状态等待GIL，让当前的线程有机会不被中断继续执行。这个行为只在MRI中，C编写的Ruby代码才有。</p>\n<p>这个行为消除了MRI中很多可能发生的竞争环境。从这个角度来说，GIL是MRI的一个严格内部实现。它保持了MRI的安全性。</p>\n<p>但是还有一个问题没有得到回答。GIL是否保证了你编写的所有Ruby代码线程安全？</p>\n<p>我们在第三篇里面会回答这个问题。</p>"},{"title":"ruby2.0下使用json遇到的坑","date":"2013-11-25T01:53:10.000Z","_content":"\n## ruby 2.0 json的坑\n\nruby2.0已经内置了对json的支持，不过在使用时遇到了一些问题。上代码：\n\n```ruby\n      File.open(omsys_file, 'r') do |f|\n        omsys_data = JSON.parse(f.read)\n\n        converter = CawGenerator::Caw::Converter.new\n\n        ret = converter.convert(omsys_data, error_file)\n\n        File.open(out_file, 'w') do |f|\n          f.write(JSON.pretty_generate(ret))\n        end\n      end\n```\n\n结果代码在JSON.parse的时候抛出异常了：\n\n```\nC:/Ruby200/lib/ruby/2.0.0/json/common.rb:155:in `encode': \"\\xA7\\x86\" from GBK to UTF-8 (Encoding::UndefinedConversionError)\n        from C:/Ruby200/lib/ruby/2.0.0/json/common.rb:155:in `initialize'\n        from C:/Ruby200/lib/ruby/2.0.0/json/common.rb:155:in `new'\n        from C:/Ruby200/lib/ruby/2.0.0/json/common.rb:155:in `parse'\n```\n\n啥原因呢？从错误来看是Json无法把GBK格式编码转换为UTF-8编码。不过我已经确认过了，要打开的json格式文件确实是UTF-8格式，怎么会是GBK编码呢？\n\n<!-- more -->\n\n加一行代码调试看看：\n\n```ruby\n      File.open(omsys_file, 'r') do |f|\n        data = f.read\n        p data.encoding\n        omsys_data = JSON.parse(f.read)\n\n        converter = CawGenerator::Caw::Converter.new\n\n        ret = converter.convert(omsys_data, error_file)\n\n        File.open(out_file, 'w') do |f|\n          f.write(JSON.pretty_generate(ret))\n        end\n      end\n```\n\n输出结果 :exclamation: :\n\n```\n#<Encoding:GBK>\n```\n\n额，原来是读取的时候编码格式就错误了。ruby1.9以上版本已经支持在读取文件时指定编码格式，给读取加上UTF-8就OK了。\n\n```ruby\n      # NOTE:the omsys json file is utf-8 format.So remember to load it with r:utf-8,\n      #  otherwize the load string will be GBK format.Json library can only parse utf-8\n      #  data!\n      #\n      File.open(omsys_file, 'r:UTF-8') do |f|\n        omsys_data = JSON.parse(f.read)\n\n        converter = CawGenerator::Caw::Converter.new\n\n        ret = converter.convert(omsys_data, error_file)\n\n        File.open(out_file, 'w') do |f|\n          f.write(JSON.pretty_generate(ret))\n        end\n      end\n```\n","source":"_posts/ruby_json_error.md","raw":"title: ruby2.0下使用json遇到的坑\ndate: 2013/11/25 9:53:10\ncategories:\n  - ruby\ntags:\n  - json\n  - ruby\n---\n\n## ruby 2.0 json的坑\n\nruby2.0已经内置了对json的支持，不过在使用时遇到了一些问题。上代码：\n\n```ruby\n      File.open(omsys_file, 'r') do |f|\n        omsys_data = JSON.parse(f.read)\n\n        converter = CawGenerator::Caw::Converter.new\n\n        ret = converter.convert(omsys_data, error_file)\n\n        File.open(out_file, 'w') do |f|\n          f.write(JSON.pretty_generate(ret))\n        end\n      end\n```\n\n结果代码在JSON.parse的时候抛出异常了：\n\n```\nC:/Ruby200/lib/ruby/2.0.0/json/common.rb:155:in `encode': \"\\xA7\\x86\" from GBK to UTF-8 (Encoding::UndefinedConversionError)\n        from C:/Ruby200/lib/ruby/2.0.0/json/common.rb:155:in `initialize'\n        from C:/Ruby200/lib/ruby/2.0.0/json/common.rb:155:in `new'\n        from C:/Ruby200/lib/ruby/2.0.0/json/common.rb:155:in `parse'\n```\n\n啥原因呢？从错误来看是Json无法把GBK格式编码转换为UTF-8编码。不过我已经确认过了，要打开的json格式文件确实是UTF-8格式，怎么会是GBK编码呢？\n\n<!-- more -->\n\n加一行代码调试看看：\n\n```ruby\n      File.open(omsys_file, 'r') do |f|\n        data = f.read\n        p data.encoding\n        omsys_data = JSON.parse(f.read)\n\n        converter = CawGenerator::Caw::Converter.new\n\n        ret = converter.convert(omsys_data, error_file)\n\n        File.open(out_file, 'w') do |f|\n          f.write(JSON.pretty_generate(ret))\n        end\n      end\n```\n\n输出结果 :exclamation: :\n\n```\n#<Encoding:GBK>\n```\n\n额，原来是读取的时候编码格式就错误了。ruby1.9以上版本已经支持在读取文件时指定编码格式，给读取加上UTF-8就OK了。\n\n```ruby\n      # NOTE:the omsys json file is utf-8 format.So remember to load it with r:utf-8,\n      #  otherwize the load string will be GBK format.Json library can only parse utf-8\n      #  data!\n      #\n      File.open(omsys_file, 'r:UTF-8') do |f|\n        omsys_data = JSON.parse(f.read)\n\n        converter = CawGenerator::Caw::Converter.new\n\n        ret = converter.convert(omsys_data, error_file)\n\n        File.open(out_file, 'w') do |f|\n          f.write(JSON.pretty_generate(ret))\n        end\n      end\n```\n","slug":"ruby_json_error","published":1,"updated":"2016-12-14T14:53:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizij4biu0005p6ddr17vas9g","content":"<h2 id=\"ruby-2-0-json的坑\"><a href=\"#ruby-2-0-json的坑\" class=\"headerlink\" title=\"ruby 2.0 json的坑\"></a>ruby 2.0 json的坑</h2><p>ruby2.0已经内置了对json的支持，不过在使用时遇到了一些问题。上代码：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">File.open(omsys_file, <span class=\"string\">'r'</span>) <span class=\"keyword\">do</span> <span class=\"params\">|f|</span></div><div class=\"line\">  omsys_data = JSON.parse(f.read)</div><div class=\"line\"></div><div class=\"line\">  converter = CawGenerator::Caw::Converter.new</div><div class=\"line\"></div><div class=\"line\">  ret = converter.convert(omsys_data, error_file)</div><div class=\"line\"></div><div class=\"line\">  File.open(out_file, <span class=\"string\">'w'</span>) <span class=\"keyword\">do</span> <span class=\"params\">|f|</span></div><div class=\"line\">    f.write(JSON.pretty_generate(ret))</div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>结果代码在JSON.parse的时候抛出异常了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">C:/Ruby200/lib/ruby/2.0.0/json/common.rb:155:in `encode&apos;: &quot;\\xA7\\x86&quot; from GBK to UTF-8 (Encoding::UndefinedConversionError)</div><div class=\"line\">        from C:/Ruby200/lib/ruby/2.0.0/json/common.rb:155:in `initialize&apos;</div><div class=\"line\">        from C:/Ruby200/lib/ruby/2.0.0/json/common.rb:155:in `new&apos;</div><div class=\"line\">        from C:/Ruby200/lib/ruby/2.0.0/json/common.rb:155:in `parse&apos;</div></pre></td></tr></table></figure>\n<p>啥原因呢？从错误来看是Json无法把GBK格式编码转换为UTF-8编码。不过我已经确认过了，要打开的json格式文件确实是UTF-8格式，怎么会是GBK编码呢？</p>\n<a id=\"more\"></a>\n<p>加一行代码调试看看：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">File.open(omsys_file, <span class=\"string\">'r'</span>) <span class=\"keyword\">do</span> <span class=\"params\">|f|</span></div><div class=\"line\">  data = f.read</div><div class=\"line\">  p data.encoding</div><div class=\"line\">  omsys_data = JSON.parse(f.read)</div><div class=\"line\"></div><div class=\"line\">  converter = CawGenerator::Caw::Converter.new</div><div class=\"line\"></div><div class=\"line\">  ret = converter.convert(omsys_data, error_file)</div><div class=\"line\"></div><div class=\"line\">  File.open(out_file, <span class=\"string\">'w'</span>) <span class=\"keyword\">do</span> <span class=\"params\">|f|</span></div><div class=\"line\">    f.write(JSON.pretty_generate(ret))</div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>输出结果 :exclamation: :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#&lt;Encoding:GBK&gt;</div></pre></td></tr></table></figure>\n<p>额，原来是读取的时候编码格式就错误了。ruby1.9以上版本已经支持在读取文件时指定编码格式，给读取加上UTF-8就OK了。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># <span class=\"doctag\">NOTE:</span>the omsys json file is utf-8 format.So remember to load it with r:utf-8,</span></div><div class=\"line\"><span class=\"comment\">#  otherwize the load string will be GBK format.Json library can only parse utf-8</span></div><div class=\"line\"><span class=\"comment\">#  data!</span></div><div class=\"line\"><span class=\"comment\">#</span></div><div class=\"line\">File.open(omsys_file, <span class=\"string\">'r:UTF-8'</span>) <span class=\"keyword\">do</span> <span class=\"params\">|f|</span></div><div class=\"line\">  omsys_data = JSON.parse(f.read)</div><div class=\"line\"></div><div class=\"line\">  converter = CawGenerator::Caw::Converter.new</div><div class=\"line\"></div><div class=\"line\">  ret = converter.convert(omsys_data, error_file)</div><div class=\"line\"></div><div class=\"line\">  File.open(out_file, <span class=\"string\">'w'</span>) <span class=\"keyword\">do</span> <span class=\"params\">|f|</span></div><div class=\"line\">    f.write(JSON.pretty_generate(ret))</div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n","excerpt":"<h2 id=\"ruby-2-0-json的坑\"><a href=\"#ruby-2-0-json的坑\" class=\"headerlink\" title=\"ruby 2.0 json的坑\"></a>ruby 2.0 json的坑</h2><p>ruby2.0已经内置了对json的支持，不过在使用时遇到了一些问题。上代码：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">File.open(omsys_file, <span class=\"string\">'r'</span>) <span class=\"keyword\">do</span> <span class=\"params\">|f|</span></div><div class=\"line\">  omsys_data = JSON.parse(f.read)</div><div class=\"line\"></div><div class=\"line\">  converter = CawGenerator::Caw::Converter.new</div><div class=\"line\"></div><div class=\"line\">  ret = converter.convert(omsys_data, error_file)</div><div class=\"line\"></div><div class=\"line\">  File.open(out_file, <span class=\"string\">'w'</span>) <span class=\"keyword\">do</span> <span class=\"params\">|f|</span></div><div class=\"line\">    f.write(JSON.pretty_generate(ret))</div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>结果代码在JSON.parse的时候抛出异常了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">C:/Ruby200/lib/ruby/2.0.0/json/common.rb:155:in `encode&apos;: &quot;\\xA7\\x86&quot; from GBK to UTF-8 (Encoding::UndefinedConversionError)</div><div class=\"line\">        from C:/Ruby200/lib/ruby/2.0.0/json/common.rb:155:in `initialize&apos;</div><div class=\"line\">        from C:/Ruby200/lib/ruby/2.0.0/json/common.rb:155:in `new&apos;</div><div class=\"line\">        from C:/Ruby200/lib/ruby/2.0.0/json/common.rb:155:in `parse&apos;</div></pre></td></tr></table></figure>\n<p>啥原因呢？从错误来看是Json无法把GBK格式编码转换为UTF-8编码。不过我已经确认过了，要打开的json格式文件确实是UTF-8格式，怎么会是GBK编码呢？</p>","more":"<p>加一行代码调试看看：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">File.open(omsys_file, <span class=\"string\">'r'</span>) <span class=\"keyword\">do</span> <span class=\"params\">|f|</span></div><div class=\"line\">  data = f.read</div><div class=\"line\">  p data.encoding</div><div class=\"line\">  omsys_data = JSON.parse(f.read)</div><div class=\"line\"></div><div class=\"line\">  converter = CawGenerator::Caw::Converter.new</div><div class=\"line\"></div><div class=\"line\">  ret = converter.convert(omsys_data, error_file)</div><div class=\"line\"></div><div class=\"line\">  File.open(out_file, <span class=\"string\">'w'</span>) <span class=\"keyword\">do</span> <span class=\"params\">|f|</span></div><div class=\"line\">    f.write(JSON.pretty_generate(ret))</div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>输出结果 :exclamation: :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#&lt;Encoding:GBK&gt;</div></pre></td></tr></table></figure>\n<p>额，原来是读取的时候编码格式就错误了。ruby1.9以上版本已经支持在读取文件时指定编码格式，给读取加上UTF-8就OK了。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># <span class=\"doctag\">NOTE:</span>the omsys json file is utf-8 format.So remember to load it with r:utf-8,</span></div><div class=\"line\"><span class=\"comment\">#  otherwize the load string will be GBK format.Json library can only parse utf-8</span></div><div class=\"line\"><span class=\"comment\">#  data!</span></div><div class=\"line\"><span class=\"comment\">#</span></div><div class=\"line\">File.open(omsys_file, <span class=\"string\">'r:UTF-8'</span>) <span class=\"keyword\">do</span> <span class=\"params\">|f|</span></div><div class=\"line\">  omsys_data = JSON.parse(f.read)</div><div class=\"line\"></div><div class=\"line\">  converter = CawGenerator::Caw::Converter.new</div><div class=\"line\"></div><div class=\"line\">  ret = converter.convert(omsys_data, error_file)</div><div class=\"line\"></div><div class=\"line\">  File.open(out_file, <span class=\"string\">'w'</span>) <span class=\"keyword\">do</span> <span class=\"params\">|f|</span></div><div class=\"line\">    f.write(JSON.pretty_generate(ret))</div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>"},{"title":"四川车侣网优化分析","date":"2015-05-02T07:29:00.000Z","_content":"\n# 车侣网存在问题\n\n## 首页加载慢\n车侣网首页加载时间超长，需要30秒以上时间。\n\n我们看看Chrome的加载记录：\n\n![homepage](http://7vzu7z.com1.z0.glb.clouddn.com/2015/05/02/shichuanchelv.png)\n\n通过加载记录我们可以很清楚的发现，图片加载占用了太多的时间。为什么图片加载这么慢？因为浏览器跟站点的并发数目是有限制的，一般是4-6个。这意味着如果把大量的图片都放在一个网站上，浏览器下载的效率很低，很多图片会处于pending状态，等待下载完成。\n\n我们有什么办法改进首页的加载呢？方法如下：\n\n1. 有些图片的效果当前通过css文件已经可以完全实现。因此这部分的图片就直接转换为css代码，省去了单个文件的下载，容量也小很多。\n2. 采用按需加载图片模式。用户当前看到的部分才加载图片，看不到的就不加载，这也能极大得提升加载速度。\n3. 将图片保存在[又拍云](https://www.upyun.com/index.html)或者[七牛云](www.qiniu.com)这种专业的图片存储商上，价格挺便宜。\n\n## 网站设计不合理\n商城是一个负荷很高的网站，不应该跟车侣网放在同一个服务器上，应该单独放一个服务器。\n\n\n","source":"_posts/scchelv.md","raw":"title: 四川车侣网优化分析\ndate: 2015/05/02 15:29:00\ncategories:\n  - web\ntags:\n  - 性能\n---\n\n# 车侣网存在问题\n\n## 首页加载慢\n车侣网首页加载时间超长，需要30秒以上时间。\n\n我们看看Chrome的加载记录：\n\n![homepage](http://7vzu7z.com1.z0.glb.clouddn.com/2015/05/02/shichuanchelv.png)\n\n通过加载记录我们可以很清楚的发现，图片加载占用了太多的时间。为什么图片加载这么慢？因为浏览器跟站点的并发数目是有限制的，一般是4-6个。这意味着如果把大量的图片都放在一个网站上，浏览器下载的效率很低，很多图片会处于pending状态，等待下载完成。\n\n我们有什么办法改进首页的加载呢？方法如下：\n\n1. 有些图片的效果当前通过css文件已经可以完全实现。因此这部分的图片就直接转换为css代码，省去了单个文件的下载，容量也小很多。\n2. 采用按需加载图片模式。用户当前看到的部分才加载图片，看不到的就不加载，这也能极大得提升加载速度。\n3. 将图片保存在[又拍云](https://www.upyun.com/index.html)或者[七牛云](www.qiniu.com)这种专业的图片存储商上，价格挺便宜。\n\n## 网站设计不合理\n商城是一个负荷很高的网站，不应该跟车侣网放在同一个服务器上，应该单独放一个服务器。\n\n\n","slug":"scchelv","published":1,"updated":"2016-12-14T14:53:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizij4bix0006p6ddyxe69i4y","content":"<h1 id=\"车侣网存在问题\"><a href=\"#车侣网存在问题\" class=\"headerlink\" title=\"车侣网存在问题\"></a>车侣网存在问题</h1><h2 id=\"首页加载慢\"><a href=\"#首页加载慢\" class=\"headerlink\" title=\"首页加载慢\"></a>首页加载慢</h2><p>车侣网首页加载时间超长，需要30秒以上时间。</p>\n<p>我们看看Chrome的加载记录：</p>\n<p><img src=\"http://7vzu7z.com1.z0.glb.clouddn.com/2015/05/02/shichuanchelv.png\" alt=\"homepage\"></p>\n<p>通过加载记录我们可以很清楚的发现，图片加载占用了太多的时间。为什么图片加载这么慢？因为浏览器跟站点的并发数目是有限制的，一般是4-6个。这意味着如果把大量的图片都放在一个网站上，浏览器下载的效率很低，很多图片会处于pending状态，等待下载完成。</p>\n<p>我们有什么办法改进首页的加载呢？方法如下：</p>\n<ol>\n<li>有些图片的效果当前通过css文件已经可以完全实现。因此这部分的图片就直接转换为css代码，省去了单个文件的下载，容量也小很多。</li>\n<li>采用按需加载图片模式。用户当前看到的部分才加载图片，看不到的就不加载，这也能极大得提升加载速度。</li>\n<li>将图片保存在<a href=\"https://www.upyun.com/index.html\" target=\"_blank\" rel=\"external\">又拍云</a>或者<a href=\"www.qiniu.com\">七牛云</a>这种专业的图片存储商上，价格挺便宜。</li>\n</ol>\n<h2 id=\"网站设计不合理\"><a href=\"#网站设计不合理\" class=\"headerlink\" title=\"网站设计不合理\"></a>网站设计不合理</h2><p>商城是一个负荷很高的网站，不应该跟车侣网放在同一个服务器上，应该单独放一个服务器。</p>\n","excerpt":"","more":"<h1 id=\"车侣网存在问题\"><a href=\"#车侣网存在问题\" class=\"headerlink\" title=\"车侣网存在问题\"></a>车侣网存在问题</h1><h2 id=\"首页加载慢\"><a href=\"#首页加载慢\" class=\"headerlink\" title=\"首页加载慢\"></a>首页加载慢</h2><p>车侣网首页加载时间超长，需要30秒以上时间。</p>\n<p>我们看看Chrome的加载记录：</p>\n<p><img src=\"http://7vzu7z.com1.z0.glb.clouddn.com/2015/05/02/shichuanchelv.png\" alt=\"homepage\"></p>\n<p>通过加载记录我们可以很清楚的发现，图片加载占用了太多的时间。为什么图片加载这么慢？因为浏览器跟站点的并发数目是有限制的，一般是4-6个。这意味着如果把大量的图片都放在一个网站上，浏览器下载的效率很低，很多图片会处于pending状态，等待下载完成。</p>\n<p>我们有什么办法改进首页的加载呢？方法如下：</p>\n<ol>\n<li>有些图片的效果当前通过css文件已经可以完全实现。因此这部分的图片就直接转换为css代码，省去了单个文件的下载，容量也小很多。</li>\n<li>采用按需加载图片模式。用户当前看到的部分才加载图片，看不到的就不加载，这也能极大得提升加载速度。</li>\n<li>将图片保存在<a href=\"https://www.upyun.com/index.html\">又拍云</a>或者<a href=\"www.qiniu.com\">七牛云</a>这种专业的图片存储商上，价格挺便宜。</li>\n</ol>\n<h2 id=\"网站设计不合理\"><a href=\"#网站设计不合理\" class=\"headerlink\" title=\"网站设计不合理\"></a>网站设计不合理</h2><p>商城是一个负荷很高的网站，不应该跟车侣网放在同一个服务器上，应该单独放一个服务器。</p>\n"},{"title":"使用SimpleCov进行Ruby代码覆盖率统计","date":"2014-10-24T09:32:10.000Z","_content":"还在为Ruby代码的质量担心吗？`SimpleCov`来帮助你了！\n\n## SimpleCov是啥\n\n`SimpleCov`是一个Ruby代码覆盖率分析工具。它使用Ruby内置的代码覆盖率库，但是提供一个更清晰、简单的API用于过滤、分组、合并、格式化和显示这些数据。\n\n看看在我们项目中实际应用中的效果：\n\n<!-- more -->\n\n代码覆盖率总览：\n\n![cov1](http://7vzu7z.com1.z0.glb.clouddn.com/2014-10-27_simplecov_group.png)\n\n单个文件代码覆盖率：\n\n![cov2](http://7vzu7z.com1.z0.glb.clouddn.com/2014-10-27_simplecov_file.png)\n\n## 如何使用\n\n`SimpleCov`只支持Ruby1.9以上版本（1.8请使用rcov），以`minitest`举例说明:\n\n1. 首先在`Gemfile`中增加`SimpleCov`\n\n    ```ruby\n    gem 'simplecov', :require => false, :group => :test\n    ```\n\n2. 然后在rakefile中增加\n\n    ```ruby\n    desc 'Run test with simple coverage test'\n    task :cov do\n      require 'simplecov'\n      SimpleCov.start\n\n      Dir.glob(File.join(__dir__, 'test', '**', '*.rb')) { |file|\n        require file\n      }\n    end\n    ```\n\n    **注意:`SimpleCov.start`必须在你的测试代码之前运行，才能跟踪代码覆盖率。之后加入没有任何效果！**\n\n3. 运行rake任务\n\n    ```\n    rake cov\n    ```\n\n4. 在`coverage`目录查看覆盖率报告\n\n总体来说，`simplecov`是一个简单易用的代码率覆盖统计工具，值得一试。\n\n> 更详细的文档资料请参考：https://github.com/colszowka/simplecov\n","source":"_posts/simple_cov.md","raw":"title: 使用SimpleCov进行Ruby代码覆盖率统计\ndate: 2014/10/24 17:32:10\ncategories:\n  - ruby\ntags:\n  - 覆盖率\n---\n还在为Ruby代码的质量担心吗？`SimpleCov`来帮助你了！\n\n## SimpleCov是啥\n\n`SimpleCov`是一个Ruby代码覆盖率分析工具。它使用Ruby内置的代码覆盖率库，但是提供一个更清晰、简单的API用于过滤、分组、合并、格式化和显示这些数据。\n\n看看在我们项目中实际应用中的效果：\n\n<!-- more -->\n\n代码覆盖率总览：\n\n![cov1](http://7vzu7z.com1.z0.glb.clouddn.com/2014-10-27_simplecov_group.png)\n\n单个文件代码覆盖率：\n\n![cov2](http://7vzu7z.com1.z0.glb.clouddn.com/2014-10-27_simplecov_file.png)\n\n## 如何使用\n\n`SimpleCov`只支持Ruby1.9以上版本（1.8请使用rcov），以`minitest`举例说明:\n\n1. 首先在`Gemfile`中增加`SimpleCov`\n\n    ```ruby\n    gem 'simplecov', :require => false, :group => :test\n    ```\n\n2. 然后在rakefile中增加\n\n    ```ruby\n    desc 'Run test with simple coverage test'\n    task :cov do\n      require 'simplecov'\n      SimpleCov.start\n\n      Dir.glob(File.join(__dir__, 'test', '**', '*.rb')) { |file|\n        require file\n      }\n    end\n    ```\n\n    **注意:`SimpleCov.start`必须在你的测试代码之前运行，才能跟踪代码覆盖率。之后加入没有任何效果！**\n\n3. 运行rake任务\n\n    ```\n    rake cov\n    ```\n\n4. 在`coverage`目录查看覆盖率报告\n\n总体来说，`simplecov`是一个简单易用的代码率覆盖统计工具，值得一试。\n\n> 更详细的文档资料请参考：https://github.com/colszowka/simplecov\n","slug":"simple_cov","published":1,"updated":"2016-12-14T14:53:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizij4bj00007p6ddu6bff1xu","content":"<p>还在为Ruby代码的质量担心吗？<code>SimpleCov</code>来帮助你了！</p>\n<h2 id=\"SimpleCov是啥\"><a href=\"#SimpleCov是啥\" class=\"headerlink\" title=\"SimpleCov是啥\"></a>SimpleCov是啥</h2><p><code>SimpleCov</code>是一个Ruby代码覆盖率分析工具。它使用Ruby内置的代码覆盖率库，但是提供一个更清晰、简单的API用于过滤、分组、合并、格式化和显示这些数据。</p>\n<p>看看在我们项目中实际应用中的效果：</p>\n<a id=\"more\"></a>\n<p>代码覆盖率总览：</p>\n<p><img src=\"http://7vzu7z.com1.z0.glb.clouddn.com/2014-10-27_simplecov_group.png\" alt=\"cov1\"></p>\n<p>单个文件代码覆盖率：</p>\n<p><img src=\"http://7vzu7z.com1.z0.glb.clouddn.com/2014-10-27_simplecov_file.png\" alt=\"cov2\"></p>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p><code>SimpleCov</code>只支持Ruby1.9以上版本（1.8请使用rcov），以<code>minitest</code>举例说明:</p>\n<ol>\n<li><p>首先在<code>Gemfile</code>中增加<code>SimpleCov</code></p>\n <figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gem <span class=\"string\">'simplecov'</span>, <span class=\"symbol\">:require</span> =&gt; <span class=\"literal\">false</span>, <span class=\"symbol\">:group</span> =&gt; <span class=\"symbol\">:test</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>然后在rakefile中增加</p>\n <figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">desc <span class=\"string\">'Run test with simple coverage test'</span></div><div class=\"line\">task <span class=\"symbol\">:cov</span> <span class=\"keyword\">do</span></div><div class=\"line\">  <span class=\"keyword\">require</span> <span class=\"string\">'simplecov'</span></div><div class=\"line\">  SimpleCov.start</div><div class=\"line\"></div><div class=\"line\">  Dir.glob(File.join(__dir_<span class=\"number\">_</span>, <span class=\"string\">'test'</span>, <span class=\"string\">'**'</span>, <span class=\"string\">'*.rb'</span>)) &#123; <span class=\"params\">|file|</span></div><div class=\"line\">    <span class=\"keyword\">require</span> file</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p> <strong>注意:<code>SimpleCov.start</code>必须在你的测试代码之前运行，才能跟踪代码覆盖率。之后加入没有任何效果！</strong></p>\n</li>\n<li><p>运行rake任务</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rake cov</div></pre></td></tr></table></figure>\n</li>\n<li><p>在<code>coverage</code>目录查看覆盖率报告</p>\n</li>\n</ol>\n<p>总体来说，<code>simplecov</code>是一个简单易用的代码率覆盖统计工具，值得一试。</p>\n<blockquote>\n<p>更详细的文档资料请参考：<a href=\"https://github.com/colszowka/simplecov\" target=\"_blank\" rel=\"external\">https://github.com/colszowka/simplecov</a></p>\n</blockquote>\n","excerpt":"<p>还在为Ruby代码的质量担心吗？<code>SimpleCov</code>来帮助你了！</p>\n<h2 id=\"SimpleCov是啥\"><a href=\"#SimpleCov是啥\" class=\"headerlink\" title=\"SimpleCov是啥\"></a>SimpleCov是啥</h2><p><code>SimpleCov</code>是一个Ruby代码覆盖率分析工具。它使用Ruby内置的代码覆盖率库，但是提供一个更清晰、简单的API用于过滤、分组、合并、格式化和显示这些数据。</p>\n<p>看看在我们项目中实际应用中的效果：</p>","more":"<p>代码覆盖率总览：</p>\n<p><img src=\"http://7vzu7z.com1.z0.glb.clouddn.com/2014-10-27_simplecov_group.png\" alt=\"cov1\"></p>\n<p>单个文件代码覆盖率：</p>\n<p><img src=\"http://7vzu7z.com1.z0.glb.clouddn.com/2014-10-27_simplecov_file.png\" alt=\"cov2\"></p>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p><code>SimpleCov</code>只支持Ruby1.9以上版本（1.8请使用rcov），以<code>minitest</code>举例说明:</p>\n<ol>\n<li><p>首先在<code>Gemfile</code>中增加<code>SimpleCov</code></p>\n <figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gem <span class=\"string\">'simplecov'</span>, <span class=\"symbol\">:require</span> =&gt; <span class=\"literal\">false</span>, <span class=\"symbol\">:group</span> =&gt; <span class=\"symbol\">:test</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>然后在rakefile中增加</p>\n <figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">desc <span class=\"string\">'Run test with simple coverage test'</span></div><div class=\"line\">task <span class=\"symbol\">:cov</span> <span class=\"keyword\">do</span></div><div class=\"line\">  <span class=\"keyword\">require</span> <span class=\"string\">'simplecov'</span></div><div class=\"line\">  SimpleCov.start</div><div class=\"line\"></div><div class=\"line\">  Dir.glob(File.join(__dir_<span class=\"number\">_</span>, <span class=\"string\">'test'</span>, <span class=\"string\">'**'</span>, <span class=\"string\">'*.rb'</span>)) &#123; <span class=\"params\">|file|</span></div><div class=\"line\">    <span class=\"keyword\">require</span> file</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p> <strong>注意:<code>SimpleCov.start</code>必须在你的测试代码之前运行，才能跟踪代码覆盖率。之后加入没有任何效果！</strong></p>\n</li>\n<li><p>运行rake任务</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rake cov</div></pre></td></tr></table></figure>\n</li>\n<li><p>在<code>coverage</code>目录查看覆盖率报告</p>\n</li>\n</ol>\n<p>总体来说，<code>simplecov</code>是一个简单易用的代码率覆盖统计工具，值得一试。</p>\n<blockquote>\n<p>更详细的文档资料请参考：<a href=\"https://github.com/colszowka/simplecov\">https://github.com/colszowka/simplecov</a></p>\n</blockquote>"},{"title":"拓扑映射还能再快吗？","date":"2014-12-13T03:46:25.000Z","_content":"\n# 简介\n拓扑映射是一个用Ruby实现的组网图搜索算法，用于在大的组网图中搜索满足用户要求的小组网。老版本的拓扑映射算法基于老旧的`ruby1.8.6`，用户已经多次反馈效率低下。听闻ruby推出了新的2.2版本，我们能否利用新版本ruby的高性能呢？\n\n# 平台级优化\n我们首先考虑代码不做大改动，切换平台和Ruby版本进行优化。方式如下：\n- Ruby升级到最新版本 **2.2**\n- 使用 **Linux** 替换Windows\n\n我们使用一个运行时间很长的测试数据来测试性能，测试机器都是公司的E6000高配服务器，12核3.2G至强CPU(`CRuby`只能用单核，多核没意义)。测试结果请参考下图：\n\n| Ruby版本     | 操作系统      | 计算时间（秒） |\n|-------------|--------------|--------------|\n|Ruby 1.8.7   |  Windows2008 |\t`790`\t        |\n|jruby 9.0.0.0.pre1|Ubuntu 12.04.2/JAVA7|\t`559`|\n|Rubinius 2.5.3|Ubuntu 12.04.2|\t`547`|\n|jruby 9.0.0.0.pre1|Ubuntu 12.04.2/JAVA8|\t`516`|\n|Ruby 2.1.3|Windows2008|\t`436`|\n|Ruby 2.1.3|Ubuntu 12.04.2|\t`324`|\n|Ruby 2.2.0|Ubuntu 12.04.2|\t`314`|\n\n从数据来看，在Ubuntu平台的Ruby2.2性能最好。在执行过程中，`Rubinius`出现过随机错误，感觉不是太稳定。\n\n<!-- more -->\n\n# 代码级优化\n通过切换操作系统和平台，通过`stackprof`分析代码性能，进行优化。参考来源见[tmm1的博客](http://tmm1.net/ruby21-profiling/)。\n\n>注意:\n>1. 以下所有优化分析/测试操作都是在Linux上执行的\n>2. `stackprof`使用了Ruby2.1提供的API，因此只支持Ruby2.1以上版本\n\n\n## 优化ConflictCheck\n经过测试，发现某些用户开发的插件中，同/跨板约束占据了大量的时间，优化效果不佳，暂时先禁用此优化规则。\n\n经过此次优化，时间下降到`276`秒。\n\n## 优化SlotType约束\n经过分析，发现约束中的SlotType约束占据了很多时间。\n\n```\n==================================\n  Mode: cpu(1000)\n  Samples: 30019 (0.06% miss rate)\n  GC: 4601 (15.33%)\n==================================\n     TOTAL    (pct)     SAMPLES    (pct)     FRAME\n     13200  (44.0%)       13200  (44.0%)     block in TopoPluginRouter::SlotAux#any?\n       839   (2.8%)         839   (2.8%)     block in TestlibTopo::Topo::Restrict#validate\n```\n\n继续跟踪:\n\n```\nstackprof tmp/perf-result.dump --method 'block in TopoPluginRouter::SlotAux#any?'          \nblock in TopoPluginRouter::SlotAux#any? (/root/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/topo-plugin-router-2.0.5/lib/topo-plugin-router/dsl/port_dsl.rb:56)\n  samples:  13200 self (44.0%)  /   13200 total (44.0%)\n  callers:\n    13200  (  100.0%)  TopoPluginRouter::SlotAux#any?\n  code:\n                                  |    56  |       items.each { |c|\n                                  |    57  |         c.strip! # 去除空格，防止多余的空格引发判断问题\n                                  |    58  |         c.downcase! # 都转换为小些再比较\n                                  |    59  | \n                                  |    60  |         # 用户如果输入错误，则跳过\n  765    (2.5%) /   765   (2.5%)  |    61  |         next if c.empty?\n                                  |    62  | \n  795    (2.6%) /   795   (2.6%)  |    63  |         if c[0].chr == '!' # 如果是!表达式，则应该不包含此slottype值\n                                  |    64  |           return true if port_slottype !~ /#{c.gsub(/^!/, '')}/\n                                  |    65  |         else # 普通表达式则包含此slottype值\n 11640   (38.8%) /  11640  (38.8%)|    66  |           return true if port_slottype =~ /#{c}/\n                                  |    67  |         end\n```\n\n可以看到正则表达式匹配占据了大量的时间。\n\n看看实现原理：\n\n```ruby\n@dtb_to_dta1.slottype(\"*BSU*|*LPUF-21*|*LPUF-40*|*LPUF-51*|*LPUF-101*|*LPUF-120*|*LPUF-240*|*LPUF-20*\")\n```\n\n用户这样写，我们需要把具体的字符串转换为8个正则表达式，一个个进行运算，因此效率很低。其实只需要写一个正则表达式即可。我们给用户提供一个改进版本的方法`slottype`，支持传入正则表达式。\n\n```ruby\nREGEX_LPUF_BUS = /(BSU|LPUF-(21|40|51|101|120|240)|LPUF-20)/i\n@dtb_to_dta1.slottype REGEX_LPUF_BUS\n```\n\n这样我们就只需要运算一次正则表达式即可，效率大为提升。\n\n经过此次改进，时间减少为`185`秒。\n\n## 优化top方法\n缓存`top`方法，减少计算量。`top`方法被频繁调用，因此我们可以缓存返回值，减少计算。\n\n原来：\n\n```ruby\n    def top\n      if parent.nil? or parent.parent.nil?\n        self\n      else\n        parent.top\n      end\n    end\n```\n\n现在：\n\n```ruby\n    def top\n      @top ||= if parent.nil? or parent.parent.nil?\n        self\n      else\n        parent.top\n      end\n    end\n```\n\n经过此次优化，时间减少为`149`秒。\n\n## 优化Minienv::Env::Connect\n\n测试数据:\n\n```text\nstackprof tmp/perf-result.dump --method 'Minienv::Env::Connect#src_port' \nMinienv::Env::Connect#src_port (/root/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/minienv-1.0.2/lib/minienv/connect.rb:20)\n  samples:  3373 self (9.0%)  /   3373 total (9.0%)\n  callers:\n     911  (   27.0%)  Minienv::Env::Connect#cross_port\n     864  (   25.6%)  Minienv::Env::Connect#half_cross?\n     796  (   23.6%)  Minienv::Env::Connect#uncross_port\n```\n\n可见`cross_port`,`half_cross?`,`uncross_port`访问次数比较多，可以利用缓存减少访问次数。优化原理同上。\n\n源代码：\n```ruby\n      def cross_port\n        if src_port.top.physical_switch?\n          src_port\n        else\n          dst_port\n        end\n      end\n```\n\n修改后:\n```ruby\n      def cross_port\n        @cross_port ||= if src_port.top.physical_switch?\n          src_port\n        else\n          dst_port\n        end\n      end\n```\n\n经过此次优化，时间减少为`131`秒。\n\n## 优化TestlibTopo::Match::ConnectorMatcher\n\n```text\n==================================\n  Mode: cpu(1000)\n  Samples: 32968 (0.05% miss rate)\n  GC: 3441 (10.44%)\n==================================\n     TOTAL    (pct)     SAMPLES    (pct)     FRAME\n      3402  (10.3%)        3365  (10.2%)     rescue in TestlibTopo::Match::ConnectorMatcher#recheck_when_loop\n```\n\n跟踪方法输出：\n```text\nrescue in TestlibTopo::Match::ConnectorMatcher#recheck_when_loop (/root/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/hunter-algorithm-2.0.0/lib/hunter/match/rule/connector_matcher.rb:64)\n  samples:  3365 self (10.2%)  /   3402 total (10.3%)\n  callers:\n    3402  (  100.0%)  TestlibTopo::Match::ConnectorMatcher#recheck_when_loop\n  callees (37 total):\n      17  (   45.9%)  Minienv::Envbase#top\n      17  (   45.9%)  Minienv::Env::Connect#src_port\n       3  (    8.1%)  Minienv::Env::Connect#dst_port\n  code:\n                                  |    64  |       yield\n                                  |    65  | \n  284    (0.9%) /   284   (0.9%)  |    66  |     rescue TestlibTopo::MatchException\n                                  |    67  |       # 如果直连链接是自环的，那么要反方向再尝试一次\n   39    (0.1%) /     2   (0.0%)  |    68  |       if env_link.src_port.top == env_link.dst_port.top\n                                  |    69  |         send method_name, env_link, candidate\n                                  |    70  |       else\n 3079    (9.3%) /  3079   (9.3%)  |    71  |         raise\n                                  |    72  |       end\n```\n\n可以看到是`raise`方法占用了大量时间。通过分析代码，发现里面是用了异常来控制执行流程。\n\n```ruby\n    rescue TestlibTopo::MatchException\n      # 如果直连链接是自环的，那么要反方向再尝试一次\n      if env_link.src_port.top == env_link.dst_port.top\n        send method_name, env_link, candidate\n      else\n        raise\n      end\n\n    end\n```\n\n用异常控制执行流程代价很高，因此我们将其修改为普通的`if else`判断即可。\n\n```ruby\n      if yield\n        true\n      else\n        if env_link.src_port.top == env_link.dst_port.top\n          send method_name, env_link, candidate\n        else\n          false\n        end\n      end\n```\n\n经过此次优化，时间下降到`109`秒。\n\n## 优化Minienv::Envbase#objname\n\n继续采样：\n```text\n==================================\n  Mode: cpu(1000)\n  Samples: 27500 (0.07% miss rate)\n  GC: 2539 (9.23%)\n==================================\n     TOTAL    (pct)     SAMPLES    (pct)     FRAME\n      2780  (10.1%)        2780  (10.1%)     Minienv::Envbase#objname\n```\n\n跟踪方法：\n```text\nMinienv::Envbase#to_s (/root/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/minienv-1.0.3/lib/minienv/env_base.rb:37)\n  samples:    30 self (0.1%)  /   2676 total (9.7%)\n  callers:\n    1401  (   52.4%)  block (2 levels) in <module:TopoPluginRouter>\n     413  (   15.4%)  block (2 levels) in TestlibTopo::Selector::CrossLinkSelector#each\n```\n\n继续跟踪：\n```text\n  callees (9787 total):\n    3601  (   36.8%)  Log4r::Logger.[]\n    2090  (   21.4%)  #<Log4r::Logger:0x007f38311ac460>.debug\n```\n\n我顶，竟然跟踪到日志里面去了。我们之前使用`log4r`的配置文件中，不是已经把日志关闭了吗？看看代码：\n\n```ruby\n  def self.debug(str = nil)\n    log = Log4r::Logger['toporesultlogger']\n    if log.debug?\n      if block_given?\n        log.debug(yield)\n      else\n        log.debug(str)\n      end\n    end\n  end\n```\n\n原来log没有缓存，导致每次都访问。还有全局日志设置为`DEBUG`，导致`log.debug(yield)`这一句仍然要执行，完全无必要，修改为`WARN`即可不执行`DEBUG`语句。\n\n因此，修改为：\n\n```ruby\n  @@log = Log4r::Logger['toporesultlogger']\n  def self.debug(str = nil)\n    if @@log.debug?\n      if block_given?\n        @@log.debug(yield)\n      else\n        @@log.debug(str)\n      end\n    end\n  end\n```\n\nlog4r日志配置文件：\n\n```yaml\nlog4r_config:\n  pre_config:\n    global:\n      level: WARN\n```\n\n优化完成后，执行时间为`63`秒。\n\n## 优化Minienv::Envbase#parent\n继续分析，执行采样：\n\n```text\n==================================\n  Mode: cpu(1000)\n  Samples: 15961 (0.11% miss rate)\n  GC: 1326 (8.31%)\n==================================\n     TOTAL    (pct)     SAMPLES    (pct)     FRAME\n      1012   (6.3%)        1012   (6.3%)     Minienv::Envbase#parent\n      2064  (12.9%)         946   (5.9%)     Minienv::Envbase#descendants\n```\n\n分析parent方法：\n```text\nMinienv::Envbase#parent (/root/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/minienv-1.0.3/lib/minienv/env_base.rb:49)\n  samples:  1012 self (6.3%)  /   1012 total (6.3%)\n  callers:\n     413  (   40.8%)  Minienv::Envbase#ancestors\n     282  (   27.9%)  block (2 levels) in <module:TopoPluginRouter>\n     117  (   11.6%)  block in TopoPluginRouter::PortDsl#slottype!\n```\n\n可见`Minienv::Envbase#ancestors`耗用时间比较多，应该考虑使用缓存。\n\n优化后执行时间为`59`秒。\n\n## 优化Minienv::Envbase#descendants\n\n继续分析：\n\n```text\n==================================\n  Mode: cpu(1000)\n  Samples: 14920 (0.12% miss rate)\n  GC: 1245 (8.34%)\n==================================\n     TOTAL    (pct)     SAMPLES    (pct)     FRAME\n      1988  (13.3%)         890   (6.0%)     Minienv::Envbase#descendants\n```\n\n该来的还是会来的……继续做方法缓存。需要注意的是：如果用户的插件不修改组网图，那么方法缓存的数据是没有问题的。如果用户插件修改修改了组网图结构，那么可能会有问题。\n\n## 优化剩余方法\n经过分析，基本上都是要缓存方法，就不再详细说明了。\n\n## 最终结果\n\n```text\n==================================\n  Mode: cpu(1000)\n  Samples: 11537 (0.16% miss rate)\n  GC: 971 (8.42%)\n==================================\n     TOTAL    (pct)     SAMPLES    (pct)     FRAME\n       704   (6.1%)         704   (6.1%)     Minienv::Env::Connect#src_port\n       623   (5.4%)         623   (5.4%)     block in TestlibTopo::Topo::Restrict#validate\n```\n\n最终经过分析，采样的代码基本上都是在执行约束了，没有进一步优化空间。下一步优化只能从算法本身来优化：\n\n- 增加优化规则，过滤一些分支\n- 增加多线程并发运算（`CRuby`暂时不支持，考虑使用`JRuby`或者`Rubinius`）\n\n最终优化效果：\n\n| Ruby版本     | 操作系统      | 计算时间（秒） |      优化步骤      |\n|-------------|--------------|--------------|------------------|\n|Ruby 1.8.7   | Windows2008  |\t`790`\t    |                  |   \n|jruby 9.0.0.0.pre1|Ubuntu 12.04.2/JAVA7|\t`559`|\t替换为jruby|\n|Rubinius 2.5.3|Ubuntu 12.04.2|\t`547`       |替换为Rbx          |\n|jruby 9.0.0.0.pre1|Ubuntu 12.04.2/JAVA8\t|`516`|\t升级Java版本|  \n|Ruby 2.1.3   |Windows2008   |  `436`       | 升级CRuby到`2.1.3`|\n|Ruby 2.1.3   |Ubuntu 12.04.2|\t`324`       |\t替换操作系统为Ubuntu|\n|Ruby 2.2.0   |Ubuntu 12.04.2|\t`314`\t    | 升级CRuby到`2.2.0`|\n|Ruby 2.2.0   |Ubuntu 12.04.2|\t`276`\t    |去掉ConflictCheck检查|\n|Ruby 2.2.0   |Ubuntu 12.04.2|  `185`       |优化SlotType约束|\n|Ruby 2.2.0   |Ubuntu 12.04.2|  `149`       |优化top方法|\n|Ruby 2.2.0   |Ubuntu 12.04.2|  `131`       |优化uncross_port方法|\n|Ruby 2.2.0   |Ubuntu 12.04.2|  `109`       |优化ConnectorMatcher类|\n|Ruby 2.2.0   |Ubuntu 12.04.2|  `63`       |优化日志Envbase#objname|\n|Ruby 2.2.0   |Ubuntu 12.04.2|  `46`       |最终优化|\n\n# 结论\n总结了一下算法优化的方法：\n\n1. 使用高版本Ruby，一般新版本Ruby在性能方面比老版本都要高\n2. 尽量使用Linux平台，效率上会比Windows平台高\n3. 使用性能分析器(Profiler)对算法进行分析，找到消耗CPU最多的代码进行优化\n    - 去掉不需要的计算代码\n    - 缓存计算结果，避免重复计算\n    - 不要使用异常控制执行流程\n    - 能合并的操作尽量合并\n    - 注意日志记录对性能的影响\n","source":"_posts/topomatch_stackprof.md","raw":"title: 拓扑映射还能再快吗？\ndate: 2014/12/13 11:46:25\ncategories:\n  - ruby\ntags:\n  - stackprof\n  - ruby\n  - 优化\n---\n\n# 简介\n拓扑映射是一个用Ruby实现的组网图搜索算法，用于在大的组网图中搜索满足用户要求的小组网。老版本的拓扑映射算法基于老旧的`ruby1.8.6`，用户已经多次反馈效率低下。听闻ruby推出了新的2.2版本，我们能否利用新版本ruby的高性能呢？\n\n# 平台级优化\n我们首先考虑代码不做大改动，切换平台和Ruby版本进行优化。方式如下：\n- Ruby升级到最新版本 **2.2**\n- 使用 **Linux** 替换Windows\n\n我们使用一个运行时间很长的测试数据来测试性能，测试机器都是公司的E6000高配服务器，12核3.2G至强CPU(`CRuby`只能用单核，多核没意义)。测试结果请参考下图：\n\n| Ruby版本     | 操作系统      | 计算时间（秒） |\n|-------------|--------------|--------------|\n|Ruby 1.8.7   |  Windows2008 |\t`790`\t        |\n|jruby 9.0.0.0.pre1|Ubuntu 12.04.2/JAVA7|\t`559`|\n|Rubinius 2.5.3|Ubuntu 12.04.2|\t`547`|\n|jruby 9.0.0.0.pre1|Ubuntu 12.04.2/JAVA8|\t`516`|\n|Ruby 2.1.3|Windows2008|\t`436`|\n|Ruby 2.1.3|Ubuntu 12.04.2|\t`324`|\n|Ruby 2.2.0|Ubuntu 12.04.2|\t`314`|\n\n从数据来看，在Ubuntu平台的Ruby2.2性能最好。在执行过程中，`Rubinius`出现过随机错误，感觉不是太稳定。\n\n<!-- more -->\n\n# 代码级优化\n通过切换操作系统和平台，通过`stackprof`分析代码性能，进行优化。参考来源见[tmm1的博客](http://tmm1.net/ruby21-profiling/)。\n\n>注意:\n>1. 以下所有优化分析/测试操作都是在Linux上执行的\n>2. `stackprof`使用了Ruby2.1提供的API，因此只支持Ruby2.1以上版本\n\n\n## 优化ConflictCheck\n经过测试，发现某些用户开发的插件中，同/跨板约束占据了大量的时间，优化效果不佳，暂时先禁用此优化规则。\n\n经过此次优化，时间下降到`276`秒。\n\n## 优化SlotType约束\n经过分析，发现约束中的SlotType约束占据了很多时间。\n\n```\n==================================\n  Mode: cpu(1000)\n  Samples: 30019 (0.06% miss rate)\n  GC: 4601 (15.33%)\n==================================\n     TOTAL    (pct)     SAMPLES    (pct)     FRAME\n     13200  (44.0%)       13200  (44.0%)     block in TopoPluginRouter::SlotAux#any?\n       839   (2.8%)         839   (2.8%)     block in TestlibTopo::Topo::Restrict#validate\n```\n\n继续跟踪:\n\n```\nstackprof tmp/perf-result.dump --method 'block in TopoPluginRouter::SlotAux#any?'          \nblock in TopoPluginRouter::SlotAux#any? (/root/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/topo-plugin-router-2.0.5/lib/topo-plugin-router/dsl/port_dsl.rb:56)\n  samples:  13200 self (44.0%)  /   13200 total (44.0%)\n  callers:\n    13200  (  100.0%)  TopoPluginRouter::SlotAux#any?\n  code:\n                                  |    56  |       items.each { |c|\n                                  |    57  |         c.strip! # 去除空格，防止多余的空格引发判断问题\n                                  |    58  |         c.downcase! # 都转换为小些再比较\n                                  |    59  | \n                                  |    60  |         # 用户如果输入错误，则跳过\n  765    (2.5%) /   765   (2.5%)  |    61  |         next if c.empty?\n                                  |    62  | \n  795    (2.6%) /   795   (2.6%)  |    63  |         if c[0].chr == '!' # 如果是!表达式，则应该不包含此slottype值\n                                  |    64  |           return true if port_slottype !~ /#{c.gsub(/^!/, '')}/\n                                  |    65  |         else # 普通表达式则包含此slottype值\n 11640   (38.8%) /  11640  (38.8%)|    66  |           return true if port_slottype =~ /#{c}/\n                                  |    67  |         end\n```\n\n可以看到正则表达式匹配占据了大量的时间。\n\n看看实现原理：\n\n```ruby\n@dtb_to_dta1.slottype(\"*BSU*|*LPUF-21*|*LPUF-40*|*LPUF-51*|*LPUF-101*|*LPUF-120*|*LPUF-240*|*LPUF-20*\")\n```\n\n用户这样写，我们需要把具体的字符串转换为8个正则表达式，一个个进行运算，因此效率很低。其实只需要写一个正则表达式即可。我们给用户提供一个改进版本的方法`slottype`，支持传入正则表达式。\n\n```ruby\nREGEX_LPUF_BUS = /(BSU|LPUF-(21|40|51|101|120|240)|LPUF-20)/i\n@dtb_to_dta1.slottype REGEX_LPUF_BUS\n```\n\n这样我们就只需要运算一次正则表达式即可，效率大为提升。\n\n经过此次改进，时间减少为`185`秒。\n\n## 优化top方法\n缓存`top`方法，减少计算量。`top`方法被频繁调用，因此我们可以缓存返回值，减少计算。\n\n原来：\n\n```ruby\n    def top\n      if parent.nil? or parent.parent.nil?\n        self\n      else\n        parent.top\n      end\n    end\n```\n\n现在：\n\n```ruby\n    def top\n      @top ||= if parent.nil? or parent.parent.nil?\n        self\n      else\n        parent.top\n      end\n    end\n```\n\n经过此次优化，时间减少为`149`秒。\n\n## 优化Minienv::Env::Connect\n\n测试数据:\n\n```text\nstackprof tmp/perf-result.dump --method 'Minienv::Env::Connect#src_port' \nMinienv::Env::Connect#src_port (/root/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/minienv-1.0.2/lib/minienv/connect.rb:20)\n  samples:  3373 self (9.0%)  /   3373 total (9.0%)\n  callers:\n     911  (   27.0%)  Minienv::Env::Connect#cross_port\n     864  (   25.6%)  Minienv::Env::Connect#half_cross?\n     796  (   23.6%)  Minienv::Env::Connect#uncross_port\n```\n\n可见`cross_port`,`half_cross?`,`uncross_port`访问次数比较多，可以利用缓存减少访问次数。优化原理同上。\n\n源代码：\n```ruby\n      def cross_port\n        if src_port.top.physical_switch?\n          src_port\n        else\n          dst_port\n        end\n      end\n```\n\n修改后:\n```ruby\n      def cross_port\n        @cross_port ||= if src_port.top.physical_switch?\n          src_port\n        else\n          dst_port\n        end\n      end\n```\n\n经过此次优化，时间减少为`131`秒。\n\n## 优化TestlibTopo::Match::ConnectorMatcher\n\n```text\n==================================\n  Mode: cpu(1000)\n  Samples: 32968 (0.05% miss rate)\n  GC: 3441 (10.44%)\n==================================\n     TOTAL    (pct)     SAMPLES    (pct)     FRAME\n      3402  (10.3%)        3365  (10.2%)     rescue in TestlibTopo::Match::ConnectorMatcher#recheck_when_loop\n```\n\n跟踪方法输出：\n```text\nrescue in TestlibTopo::Match::ConnectorMatcher#recheck_when_loop (/root/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/hunter-algorithm-2.0.0/lib/hunter/match/rule/connector_matcher.rb:64)\n  samples:  3365 self (10.2%)  /   3402 total (10.3%)\n  callers:\n    3402  (  100.0%)  TestlibTopo::Match::ConnectorMatcher#recheck_when_loop\n  callees (37 total):\n      17  (   45.9%)  Minienv::Envbase#top\n      17  (   45.9%)  Minienv::Env::Connect#src_port\n       3  (    8.1%)  Minienv::Env::Connect#dst_port\n  code:\n                                  |    64  |       yield\n                                  |    65  | \n  284    (0.9%) /   284   (0.9%)  |    66  |     rescue TestlibTopo::MatchException\n                                  |    67  |       # 如果直连链接是自环的，那么要反方向再尝试一次\n   39    (0.1%) /     2   (0.0%)  |    68  |       if env_link.src_port.top == env_link.dst_port.top\n                                  |    69  |         send method_name, env_link, candidate\n                                  |    70  |       else\n 3079    (9.3%) /  3079   (9.3%)  |    71  |         raise\n                                  |    72  |       end\n```\n\n可以看到是`raise`方法占用了大量时间。通过分析代码，发现里面是用了异常来控制执行流程。\n\n```ruby\n    rescue TestlibTopo::MatchException\n      # 如果直连链接是自环的，那么要反方向再尝试一次\n      if env_link.src_port.top == env_link.dst_port.top\n        send method_name, env_link, candidate\n      else\n        raise\n      end\n\n    end\n```\n\n用异常控制执行流程代价很高，因此我们将其修改为普通的`if else`判断即可。\n\n```ruby\n      if yield\n        true\n      else\n        if env_link.src_port.top == env_link.dst_port.top\n          send method_name, env_link, candidate\n        else\n          false\n        end\n      end\n```\n\n经过此次优化，时间下降到`109`秒。\n\n## 优化Minienv::Envbase#objname\n\n继续采样：\n```text\n==================================\n  Mode: cpu(1000)\n  Samples: 27500 (0.07% miss rate)\n  GC: 2539 (9.23%)\n==================================\n     TOTAL    (pct)     SAMPLES    (pct)     FRAME\n      2780  (10.1%)        2780  (10.1%)     Minienv::Envbase#objname\n```\n\n跟踪方法：\n```text\nMinienv::Envbase#to_s (/root/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/minienv-1.0.3/lib/minienv/env_base.rb:37)\n  samples:    30 self (0.1%)  /   2676 total (9.7%)\n  callers:\n    1401  (   52.4%)  block (2 levels) in <module:TopoPluginRouter>\n     413  (   15.4%)  block (2 levels) in TestlibTopo::Selector::CrossLinkSelector#each\n```\n\n继续跟踪：\n```text\n  callees (9787 total):\n    3601  (   36.8%)  Log4r::Logger.[]\n    2090  (   21.4%)  #<Log4r::Logger:0x007f38311ac460>.debug\n```\n\n我顶，竟然跟踪到日志里面去了。我们之前使用`log4r`的配置文件中，不是已经把日志关闭了吗？看看代码：\n\n```ruby\n  def self.debug(str = nil)\n    log = Log4r::Logger['toporesultlogger']\n    if log.debug?\n      if block_given?\n        log.debug(yield)\n      else\n        log.debug(str)\n      end\n    end\n  end\n```\n\n原来log没有缓存，导致每次都访问。还有全局日志设置为`DEBUG`，导致`log.debug(yield)`这一句仍然要执行，完全无必要，修改为`WARN`即可不执行`DEBUG`语句。\n\n因此，修改为：\n\n```ruby\n  @@log = Log4r::Logger['toporesultlogger']\n  def self.debug(str = nil)\n    if @@log.debug?\n      if block_given?\n        @@log.debug(yield)\n      else\n        @@log.debug(str)\n      end\n    end\n  end\n```\n\nlog4r日志配置文件：\n\n```yaml\nlog4r_config:\n  pre_config:\n    global:\n      level: WARN\n```\n\n优化完成后，执行时间为`63`秒。\n\n## 优化Minienv::Envbase#parent\n继续分析，执行采样：\n\n```text\n==================================\n  Mode: cpu(1000)\n  Samples: 15961 (0.11% miss rate)\n  GC: 1326 (8.31%)\n==================================\n     TOTAL    (pct)     SAMPLES    (pct)     FRAME\n      1012   (6.3%)        1012   (6.3%)     Minienv::Envbase#parent\n      2064  (12.9%)         946   (5.9%)     Minienv::Envbase#descendants\n```\n\n分析parent方法：\n```text\nMinienv::Envbase#parent (/root/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/minienv-1.0.3/lib/minienv/env_base.rb:49)\n  samples:  1012 self (6.3%)  /   1012 total (6.3%)\n  callers:\n     413  (   40.8%)  Minienv::Envbase#ancestors\n     282  (   27.9%)  block (2 levels) in <module:TopoPluginRouter>\n     117  (   11.6%)  block in TopoPluginRouter::PortDsl#slottype!\n```\n\n可见`Minienv::Envbase#ancestors`耗用时间比较多，应该考虑使用缓存。\n\n优化后执行时间为`59`秒。\n\n## 优化Minienv::Envbase#descendants\n\n继续分析：\n\n```text\n==================================\n  Mode: cpu(1000)\n  Samples: 14920 (0.12% miss rate)\n  GC: 1245 (8.34%)\n==================================\n     TOTAL    (pct)     SAMPLES    (pct)     FRAME\n      1988  (13.3%)         890   (6.0%)     Minienv::Envbase#descendants\n```\n\n该来的还是会来的……继续做方法缓存。需要注意的是：如果用户的插件不修改组网图，那么方法缓存的数据是没有问题的。如果用户插件修改修改了组网图结构，那么可能会有问题。\n\n## 优化剩余方法\n经过分析，基本上都是要缓存方法，就不再详细说明了。\n\n## 最终结果\n\n```text\n==================================\n  Mode: cpu(1000)\n  Samples: 11537 (0.16% miss rate)\n  GC: 971 (8.42%)\n==================================\n     TOTAL    (pct)     SAMPLES    (pct)     FRAME\n       704   (6.1%)         704   (6.1%)     Minienv::Env::Connect#src_port\n       623   (5.4%)         623   (5.4%)     block in TestlibTopo::Topo::Restrict#validate\n```\n\n最终经过分析，采样的代码基本上都是在执行约束了，没有进一步优化空间。下一步优化只能从算法本身来优化：\n\n- 增加优化规则，过滤一些分支\n- 增加多线程并发运算（`CRuby`暂时不支持，考虑使用`JRuby`或者`Rubinius`）\n\n最终优化效果：\n\n| Ruby版本     | 操作系统      | 计算时间（秒） |      优化步骤      |\n|-------------|--------------|--------------|------------------|\n|Ruby 1.8.7   | Windows2008  |\t`790`\t    |                  |   \n|jruby 9.0.0.0.pre1|Ubuntu 12.04.2/JAVA7|\t`559`|\t替换为jruby|\n|Rubinius 2.5.3|Ubuntu 12.04.2|\t`547`       |替换为Rbx          |\n|jruby 9.0.0.0.pre1|Ubuntu 12.04.2/JAVA8\t|`516`|\t升级Java版本|  \n|Ruby 2.1.3   |Windows2008   |  `436`       | 升级CRuby到`2.1.3`|\n|Ruby 2.1.3   |Ubuntu 12.04.2|\t`324`       |\t替换操作系统为Ubuntu|\n|Ruby 2.2.0   |Ubuntu 12.04.2|\t`314`\t    | 升级CRuby到`2.2.0`|\n|Ruby 2.2.0   |Ubuntu 12.04.2|\t`276`\t    |去掉ConflictCheck检查|\n|Ruby 2.2.0   |Ubuntu 12.04.2|  `185`       |优化SlotType约束|\n|Ruby 2.2.0   |Ubuntu 12.04.2|  `149`       |优化top方法|\n|Ruby 2.2.0   |Ubuntu 12.04.2|  `131`       |优化uncross_port方法|\n|Ruby 2.2.0   |Ubuntu 12.04.2|  `109`       |优化ConnectorMatcher类|\n|Ruby 2.2.0   |Ubuntu 12.04.2|  `63`       |优化日志Envbase#objname|\n|Ruby 2.2.0   |Ubuntu 12.04.2|  `46`       |最终优化|\n\n# 结论\n总结了一下算法优化的方法：\n\n1. 使用高版本Ruby，一般新版本Ruby在性能方面比老版本都要高\n2. 尽量使用Linux平台，效率上会比Windows平台高\n3. 使用性能分析器(Profiler)对算法进行分析，找到消耗CPU最多的代码进行优化\n    - 去掉不需要的计算代码\n    - 缓存计算结果，避免重复计算\n    - 不要使用异常控制执行流程\n    - 能合并的操作尽量合并\n    - 注意日志记录对性能的影响\n","slug":"topomatch_stackprof","published":1,"updated":"2016-12-14T14:53:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizij4bj2000ap6dd8axr0jqf","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>拓扑映射是一个用Ruby实现的组网图搜索算法，用于在大的组网图中搜索满足用户要求的小组网。老版本的拓扑映射算法基于老旧的<code>ruby1.8.6</code>，用户已经多次反馈效率低下。听闻ruby推出了新的2.2版本，我们能否利用新版本ruby的高性能呢？</p>\n<h1 id=\"平台级优化\"><a href=\"#平台级优化\" class=\"headerlink\" title=\"平台级优化\"></a>平台级优化</h1><p>我们首先考虑代码不做大改动，切换平台和Ruby版本进行优化。方式如下：</p>\n<ul>\n<li>Ruby升级到最新版本 <strong>2.2</strong></li>\n<li>使用 <strong>Linux</strong> 替换Windows</li>\n</ul>\n<p>我们使用一个运行时间很长的测试数据来测试性能，测试机器都是公司的E6000高配服务器，12核3.2G至强CPU(<code>CRuby</code>只能用单核，多核没意义)。测试结果请参考下图：</p>\n<table>\n<thead>\n<tr>\n<th>Ruby版本</th>\n<th>操作系统</th>\n<th>计算时间（秒）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Ruby 1.8.7</td>\n<td>Windows2008</td>\n<td><code>790</code></td>\n</tr>\n<tr>\n<td>jruby 9.0.0.0.pre1</td>\n<td>Ubuntu 12.04.2/JAVA7</td>\n<td><code>559</code></td>\n</tr>\n<tr>\n<td>Rubinius 2.5.3</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>547</code></td>\n</tr>\n<tr>\n<td>jruby 9.0.0.0.pre1</td>\n<td>Ubuntu 12.04.2/JAVA8</td>\n<td><code>516</code></td>\n</tr>\n<tr>\n<td>Ruby 2.1.3</td>\n<td>Windows2008</td>\n<td><code>436</code></td>\n</tr>\n<tr>\n<td>Ruby 2.1.3</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>324</code></td>\n</tr>\n<tr>\n<td>Ruby 2.2.0</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>314</code></td>\n</tr>\n</tbody>\n</table>\n<p>从数据来看，在Ubuntu平台的Ruby2.2性能最好。在执行过程中，<code>Rubinius</code>出现过随机错误，感觉不是太稳定。</p>\n<a id=\"more\"></a>\n<h1 id=\"代码级优化\"><a href=\"#代码级优化\" class=\"headerlink\" title=\"代码级优化\"></a>代码级优化</h1><p>通过切换操作系统和平台，通过<code>stackprof</code>分析代码性能，进行优化。参考来源见<a href=\"http://tmm1.net/ruby21-profiling/\" target=\"_blank\" rel=\"external\">tmm1的博客</a>。</p>\n<blockquote>\n<p>注意:</p>\n<ol>\n<li>以下所有优化分析/测试操作都是在Linux上执行的</li>\n<li><code>stackprof</code>使用了Ruby2.1提供的API，因此只支持Ruby2.1以上版本</li>\n</ol>\n</blockquote>\n<h2 id=\"优化ConflictCheck\"><a href=\"#优化ConflictCheck\" class=\"headerlink\" title=\"优化ConflictCheck\"></a>优化ConflictCheck</h2><p>经过测试，发现某些用户开发的插件中，同/跨板约束占据了大量的时间，优化效果不佳，暂时先禁用此优化规则。</p>\n<p>经过此次优化，时间下降到<code>276</code>秒。</p>\n<h2 id=\"优化SlotType约束\"><a href=\"#优化SlotType约束\" class=\"headerlink\" title=\"优化SlotType约束\"></a>优化SlotType约束</h2><p>经过分析，发现约束中的SlotType约束占据了很多时间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">==================================</div><div class=\"line\">  Mode: cpu(1000)</div><div class=\"line\">  Samples: 30019 (0.06% miss rate)</div><div class=\"line\">  GC: 4601 (15.33%)</div><div class=\"line\">==================================</div><div class=\"line\">     TOTAL    (pct)     SAMPLES    (pct)     FRAME</div><div class=\"line\">     13200  (44.0%)       13200  (44.0%)     block in TopoPluginRouter::SlotAux#any?</div><div class=\"line\">       839   (2.8%)         839   (2.8%)     block in TestlibTopo::Topo::Restrict#validate</div></pre></td></tr></table></figure>\n<p>继续跟踪:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">stackprof tmp/perf-result.dump --method &apos;block in TopoPluginRouter::SlotAux#any?&apos;          </div><div class=\"line\">block in TopoPluginRouter::SlotAux#any? (/root/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/topo-plugin-router-2.0.5/lib/topo-plugin-router/dsl/port_dsl.rb:56)</div><div class=\"line\">  samples:  13200 self (44.0%)  /   13200 total (44.0%)</div><div class=\"line\">  callers:</div><div class=\"line\">    13200  (  100.0%)  TopoPluginRouter::SlotAux#any?</div><div class=\"line\">  code:</div><div class=\"line\">                                  |    56  |       items.each &#123; |c|</div><div class=\"line\">                                  |    57  |         c.strip! # 去除空格，防止多余的空格引发判断问题</div><div class=\"line\">                                  |    58  |         c.downcase! # 都转换为小些再比较</div><div class=\"line\">                                  |    59  | </div><div class=\"line\">                                  |    60  |         # 用户如果输入错误，则跳过</div><div class=\"line\">  765    (2.5%) /   765   (2.5%)  |    61  |         next if c.empty?</div><div class=\"line\">                                  |    62  | </div><div class=\"line\">  795    (2.6%) /   795   (2.6%)  |    63  |         if c[0].chr == &apos;!&apos; # 如果是!表达式，则应该不包含此slottype值</div><div class=\"line\">                                  |    64  |           return true if port_slottype !~ /#&#123;c.gsub(/^!/, &apos;&apos;)&#125;/</div><div class=\"line\">                                  |    65  |         else # 普通表达式则包含此slottype值</div><div class=\"line\"> 11640   (38.8%) /  11640  (38.8%)|    66  |           return true if port_slottype =~ /#&#123;c&#125;/</div><div class=\"line\">                                  |    67  |         end</div></pre></td></tr></table></figure>\n<p>可以看到正则表达式匹配占据了大量的时间。</p>\n<p>看看实现原理：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@dtb_to_dta1.slottype(<span class=\"string\">\"*BSU*|*LPUF-21*|*LPUF-40*|*LPUF-51*|*LPUF-101*|*LPUF-120*|*LPUF-240*|*LPUF-20*\"</span>)</div></pre></td></tr></table></figure>\n<p>用户这样写，我们需要把具体的字符串转换为8个正则表达式，一个个进行运算，因此效率很低。其实只需要写一个正则表达式即可。我们给用户提供一个改进版本的方法<code>slottype</code>，支持传入正则表达式。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">REGEX_LPUF_BUS = <span class=\"regexp\">/(BSU|LPUF-(21|40|51|101|120|240)|LPUF-20)/i</span></div><div class=\"line\">@dtb_to_dta1.slottype REGEX_LPUF_BUS</div></pre></td></tr></table></figure>\n<p>这样我们就只需要运算一次正则表达式即可，效率大为提升。</p>\n<p>经过此次改进，时间减少为<code>185</code>秒。</p>\n<h2 id=\"优化top方法\"><a href=\"#优化top方法\" class=\"headerlink\" title=\"优化top方法\"></a>优化top方法</h2><p>缓存<code>top</code>方法，减少计算量。<code>top</code>方法被频繁调用，因此我们可以缓存返回值，减少计算。</p>\n<p>原来：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">top</span></span></div><div class=\"line\">  <span class=\"keyword\">if</span> parent.<span class=\"literal\">nil</span>? <span class=\"keyword\">or</span> parent.parent.<span class=\"literal\">nil</span>?</div><div class=\"line\">    <span class=\"keyword\">self</span></div><div class=\"line\">  <span class=\"keyword\">else</span></div><div class=\"line\">    parent.top</div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>现在：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">top</span></span></div><div class=\"line\">  @top <span class=\"params\">||</span>= <span class=\"keyword\">if</span> parent.<span class=\"literal\">nil</span>? <span class=\"keyword\">or</span> parent.parent.<span class=\"literal\">nil</span>?</div><div class=\"line\">    <span class=\"keyword\">self</span></div><div class=\"line\">  <span class=\"keyword\">else</span></div><div class=\"line\">    parent.top</div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>经过此次优化，时间减少为<code>149</code>秒。</p>\n<h2 id=\"优化Minienv-Env-Connect\"><a href=\"#优化Minienv-Env-Connect\" class=\"headerlink\" title=\"优化Minienv::Env::Connect\"></a>优化Minienv::Env::Connect</h2><p>测试数据:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">stackprof tmp/perf-result.dump --method &apos;Minienv::Env::Connect#src_port&apos; </div><div class=\"line\">Minienv::Env::Connect#src_port (/root/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/minienv-1.0.2/lib/minienv/connect.rb:20)</div><div class=\"line\">  samples:  3373 self (9.0%)  /   3373 total (9.0%)</div><div class=\"line\">  callers:</div><div class=\"line\">     911  (   27.0%)  Minienv::Env::Connect#cross_port</div><div class=\"line\">     864  (   25.6%)  Minienv::Env::Connect#half_cross?</div><div class=\"line\">     796  (   23.6%)  Minienv::Env::Connect#uncross_port</div></pre></td></tr></table></figure>\n<p>可见<code>cross_port</code>,<code>half_cross?</code>,<code>uncross_port</code>访问次数比较多，可以利用缓存减少访问次数。优化原理同上。</p>\n<p>源代码：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cross_port</span></span></div><div class=\"line\">  <span class=\"keyword\">if</span> src_port.top.physical_switch?</div><div class=\"line\">    src_port</div><div class=\"line\">  <span class=\"keyword\">else</span></div><div class=\"line\">    dst_port</div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure></p>\n<p>修改后:<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cross_port</span></span></div><div class=\"line\">  @cross_port <span class=\"params\">||</span>= <span class=\"keyword\">if</span> src_port.top.physical_switch?</div><div class=\"line\">    src_port</div><div class=\"line\">  <span class=\"keyword\">else</span></div><div class=\"line\">    dst_port</div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure></p>\n<p>经过此次优化，时间减少为<code>131</code>秒。</p>\n<h2 id=\"优化TestlibTopo-Match-ConnectorMatcher\"><a href=\"#优化TestlibTopo-Match-ConnectorMatcher\" class=\"headerlink\" title=\"优化TestlibTopo::Match::ConnectorMatcher\"></a>优化TestlibTopo::Match::ConnectorMatcher</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">==================================</div><div class=\"line\">  Mode: cpu(1000)</div><div class=\"line\">  Samples: 32968 (0.05% miss rate)</div><div class=\"line\">  GC: 3441 (10.44%)</div><div class=\"line\">==================================</div><div class=\"line\">     TOTAL    (pct)     SAMPLES    (pct)     FRAME</div><div class=\"line\">      3402  (10.3%)        3365  (10.2%)     rescue in TestlibTopo::Match::ConnectorMatcher#recheck_when_loop</div></pre></td></tr></table></figure>\n<p>跟踪方法输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">rescue in TestlibTopo::Match::ConnectorMatcher#recheck_when_loop (/root/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/hunter-algorithm-2.0.0/lib/hunter/match/rule/connector_matcher.rb:64)</div><div class=\"line\">  samples:  3365 self (10.2%)  /   3402 total (10.3%)</div><div class=\"line\">  callers:</div><div class=\"line\">    3402  (  100.0%)  TestlibTopo::Match::ConnectorMatcher#recheck_when_loop</div><div class=\"line\">  callees (37 total):</div><div class=\"line\">      17  (   45.9%)  Minienv::Envbase#top</div><div class=\"line\">      17  (   45.9%)  Minienv::Env::Connect#src_port</div><div class=\"line\">       3  (    8.1%)  Minienv::Env::Connect#dst_port</div><div class=\"line\">  code:</div><div class=\"line\">                                  |    64  |       yield</div><div class=\"line\">                                  |    65  | </div><div class=\"line\">  284    (0.9%) /   284   (0.9%)  |    66  |     rescue TestlibTopo::MatchException</div><div class=\"line\">                                  |    67  |       # 如果直连链接是自环的，那么要反方向再尝试一次</div><div class=\"line\">   39    (0.1%) /     2   (0.0%)  |    68  |       if env_link.src_port.top == env_link.dst_port.top</div><div class=\"line\">                                  |    69  |         send method_name, env_link, candidate</div><div class=\"line\">                                  |    70  |       else</div><div class=\"line\"> 3079    (9.3%) /  3079   (9.3%)  |    71  |         raise</div><div class=\"line\">                                  |    72  |       end</div></pre></td></tr></table></figure></p>\n<p>可以看到是<code>raise</code>方法占用了大量时间。通过分析代码，发现里面是用了异常来控制执行流程。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">rescue</span> TestlibTopo::MatchException</div><div class=\"line\">  <span class=\"comment\"># 如果直连链接是自环的，那么要反方向再尝试一次</span></div><div class=\"line\">  <span class=\"keyword\">if</span> env_link.src_port.top == env_link.dst_port.top</div><div class=\"line\">    send method_name, env_link, candidate</div><div class=\"line\">  <span class=\"keyword\">else</span></div><div class=\"line\">    raise</div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>用异常控制执行流程代价很高，因此我们将其修改为普通的<code>if else</code>判断即可。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">yield</span></div><div class=\"line\">  <span class=\"literal\">true</span></div><div class=\"line\"><span class=\"keyword\">else</span></div><div class=\"line\">  <span class=\"keyword\">if</span> env_link.src_port.top == env_link.dst_port.top</div><div class=\"line\">    send method_name, env_link, candidate</div><div class=\"line\">  <span class=\"keyword\">else</span></div><div class=\"line\">    <span class=\"literal\">false</span></div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>经过此次优化，时间下降到<code>109</code>秒。</p>\n<h2 id=\"优化Minienv-Envbase-objname\"><a href=\"#优化Minienv-Envbase-objname\" class=\"headerlink\" title=\"优化Minienv::Envbase#objname\"></a>优化Minienv::Envbase#objname</h2><p>继续采样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">==================================</div><div class=\"line\">  Mode: cpu(1000)</div><div class=\"line\">  Samples: 27500 (0.07% miss rate)</div><div class=\"line\">  GC: 2539 (9.23%)</div><div class=\"line\">==================================</div><div class=\"line\">     TOTAL    (pct)     SAMPLES    (pct)     FRAME</div><div class=\"line\">      2780  (10.1%)        2780  (10.1%)     Minienv::Envbase#objname</div></pre></td></tr></table></figure></p>\n<p>跟踪方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Minienv::Envbase#to_s (/root/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/minienv-1.0.3/lib/minienv/env_base.rb:37)</div><div class=\"line\">  samples:    30 self (0.1%)  /   2676 total (9.7%)</div><div class=\"line\">  callers:</div><div class=\"line\">    1401  (   52.4%)  block (2 levels) in &lt;module:TopoPluginRouter&gt;</div><div class=\"line\">     413  (   15.4%)  block (2 levels) in TestlibTopo::Selector::CrossLinkSelector#each</div></pre></td></tr></table></figure></p>\n<p>继续跟踪：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">callees (9787 total):</div><div class=\"line\">  3601  (   36.8%)  Log4r::Logger.[]</div><div class=\"line\">  2090  (   21.4%)  #&lt;Log4r::Logger:0x007f38311ac460&gt;.debug</div></pre></td></tr></table></figure></p>\n<p>我顶，竟然跟踪到日志里面去了。我们之前使用<code>log4r</code>的配置文件中，不是已经把日志关闭了吗？看看代码：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">self</span>.<span class=\"title\">debug</span><span class=\"params\">(str = <span class=\"literal\">nil</span>)</span></span></div><div class=\"line\">  log = Log4r::Logger[<span class=\"string\">'toporesultlogger'</span>]</div><div class=\"line\">  <span class=\"keyword\">if</span> log.debug?</div><div class=\"line\">    <span class=\"keyword\">if</span> block_given?</div><div class=\"line\">      log.debug(<span class=\"keyword\">yield</span>)</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">      log.debug(str)</div><div class=\"line\">    <span class=\"keyword\">end</span></div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>原来log没有缓存，导致每次都访问。还有全局日志设置为<code>DEBUG</code>，导致<code>log.debug(yield)</code>这一句仍然要执行，完全无必要，修改为<code>WARN</code>即可不执行<code>DEBUG</code>语句。</p>\n<p>因此，修改为：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@@log = Log4r::Logger[<span class=\"string\">'toporesultlogger'</span>]</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">self</span>.<span class=\"title\">debug</span><span class=\"params\">(str = <span class=\"literal\">nil</span>)</span></span></div><div class=\"line\">  <span class=\"keyword\">if</span> @@log.debug?</div><div class=\"line\">    <span class=\"keyword\">if</span> block_given?</div><div class=\"line\">      @@log.debug(<span class=\"keyword\">yield</span>)</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">      @@log.debug(str)</div><div class=\"line\">    <span class=\"keyword\">end</span></div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>log4r日志配置文件：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">log4r_config:</span></div><div class=\"line\"><span class=\"attr\">  pre_config:</span></div><div class=\"line\"><span class=\"attr\">    global:</span></div><div class=\"line\"><span class=\"attr\">      level:</span> WARN</div></pre></td></tr></table></figure>\n<p>优化完成后，执行时间为<code>63</code>秒。</p>\n<h2 id=\"优化Minienv-Envbase-parent\"><a href=\"#优化Minienv-Envbase-parent\" class=\"headerlink\" title=\"优化Minienv::Envbase#parent\"></a>优化Minienv::Envbase#parent</h2><p>继续分析，执行采样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">==================================</div><div class=\"line\">  Mode: cpu(1000)</div><div class=\"line\">  Samples: 15961 (0.11% miss rate)</div><div class=\"line\">  GC: 1326 (8.31%)</div><div class=\"line\">==================================</div><div class=\"line\">     TOTAL    (pct)     SAMPLES    (pct)     FRAME</div><div class=\"line\">      1012   (6.3%)        1012   (6.3%)     Minienv::Envbase#parent</div><div class=\"line\">      2064  (12.9%)         946   (5.9%)     Minienv::Envbase#descendants</div></pre></td></tr></table></figure>\n<p>分析parent方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Minienv::Envbase#parent (/root/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/minienv-1.0.3/lib/minienv/env_base.rb:49)</div><div class=\"line\">  samples:  1012 self (6.3%)  /   1012 total (6.3%)</div><div class=\"line\">  callers:</div><div class=\"line\">     413  (   40.8%)  Minienv::Envbase#ancestors</div><div class=\"line\">     282  (   27.9%)  block (2 levels) in &lt;module:TopoPluginRouter&gt;</div><div class=\"line\">     117  (   11.6%)  block in TopoPluginRouter::PortDsl#slottype!</div></pre></td></tr></table></figure></p>\n<p>可见<code>Minienv::Envbase#ancestors</code>耗用时间比较多，应该考虑使用缓存。</p>\n<p>优化后执行时间为<code>59</code>秒。</p>\n<h2 id=\"优化Minienv-Envbase-descendants\"><a href=\"#优化Minienv-Envbase-descendants\" class=\"headerlink\" title=\"优化Minienv::Envbase#descendants\"></a>优化Minienv::Envbase#descendants</h2><p>继续分析：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">==================================</div><div class=\"line\">  Mode: cpu(1000)</div><div class=\"line\">  Samples: 14920 (0.12% miss rate)</div><div class=\"line\">  GC: 1245 (8.34%)</div><div class=\"line\">==================================</div><div class=\"line\">     TOTAL    (pct)     SAMPLES    (pct)     FRAME</div><div class=\"line\">      1988  (13.3%)         890   (6.0%)     Minienv::Envbase#descendants</div></pre></td></tr></table></figure>\n<p>该来的还是会来的……继续做方法缓存。需要注意的是：如果用户的插件不修改组网图，那么方法缓存的数据是没有问题的。如果用户插件修改修改了组网图结构，那么可能会有问题。</p>\n<h2 id=\"优化剩余方法\"><a href=\"#优化剩余方法\" class=\"headerlink\" title=\"优化剩余方法\"></a>优化剩余方法</h2><p>经过分析，基本上都是要缓存方法，就不再详细说明了。</p>\n<h2 id=\"最终结果\"><a href=\"#最终结果\" class=\"headerlink\" title=\"最终结果\"></a>最终结果</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">==================================</div><div class=\"line\">  Mode: cpu(1000)</div><div class=\"line\">  Samples: 11537 (0.16% miss rate)</div><div class=\"line\">  GC: 971 (8.42%)</div><div class=\"line\">==================================</div><div class=\"line\">     TOTAL    (pct)     SAMPLES    (pct)     FRAME</div><div class=\"line\">       704   (6.1%)         704   (6.1%)     Minienv::Env::Connect#src_port</div><div class=\"line\">       623   (5.4%)         623   (5.4%)     block in TestlibTopo::Topo::Restrict#validate</div></pre></td></tr></table></figure>\n<p>最终经过分析，采样的代码基本上都是在执行约束了，没有进一步优化空间。下一步优化只能从算法本身来优化：</p>\n<ul>\n<li>增加优化规则，过滤一些分支</li>\n<li>增加多线程并发运算（<code>CRuby</code>暂时不支持，考虑使用<code>JRuby</code>或者<code>Rubinius</code>）</li>\n</ul>\n<p>最终优化效果：</p>\n<table>\n<thead>\n<tr>\n<th>Ruby版本</th>\n<th>操作系统</th>\n<th>计算时间（秒）</th>\n<th>优化步骤</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Ruby 1.8.7</td>\n<td>Windows2008</td>\n<td><code>790</code></td>\n<td></td>\n</tr>\n<tr>\n<td>jruby 9.0.0.0.pre1</td>\n<td>Ubuntu 12.04.2/JAVA7</td>\n<td><code>559</code></td>\n<td>替换为jruby</td>\n</tr>\n<tr>\n<td>Rubinius 2.5.3</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>547</code></td>\n<td>替换为Rbx</td>\n</tr>\n<tr>\n<td>jruby 9.0.0.0.pre1</td>\n<td>Ubuntu 12.04.2/JAVA8</td>\n<td><code>516</code></td>\n<td>升级Java版本</td>\n</tr>\n<tr>\n<td>Ruby 2.1.3</td>\n<td>Windows2008</td>\n<td><code>436</code></td>\n<td>升级CRuby到<code>2.1.3</code></td>\n</tr>\n<tr>\n<td>Ruby 2.1.3</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>324</code></td>\n<td>替换操作系统为Ubuntu</td>\n</tr>\n<tr>\n<td>Ruby 2.2.0</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>314</code></td>\n<td>升级CRuby到<code>2.2.0</code></td>\n</tr>\n<tr>\n<td>Ruby 2.2.0</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>276</code></td>\n<td>去掉ConflictCheck检查</td>\n</tr>\n<tr>\n<td>Ruby 2.2.0</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>185</code></td>\n<td>优化SlotType约束</td>\n</tr>\n<tr>\n<td>Ruby 2.2.0</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>149</code></td>\n<td>优化top方法</td>\n</tr>\n<tr>\n<td>Ruby 2.2.0</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>131</code></td>\n<td>优化uncross_port方法</td>\n</tr>\n<tr>\n<td>Ruby 2.2.0</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>109</code></td>\n<td>优化ConnectorMatcher类</td>\n</tr>\n<tr>\n<td>Ruby 2.2.0</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>63</code></td>\n<td>优化日志Envbase#objname</td>\n</tr>\n<tr>\n<td>Ruby 2.2.0</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>46</code></td>\n<td>最终优化</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>总结了一下算法优化的方法：</p>\n<ol>\n<li>使用高版本Ruby，一般新版本Ruby在性能方面比老版本都要高</li>\n<li>尽量使用Linux平台，效率上会比Windows平台高</li>\n<li>使用性能分析器(Profiler)对算法进行分析，找到消耗CPU最多的代码进行优化<ul>\n<li>去掉不需要的计算代码</li>\n<li>缓存计算结果，避免重复计算</li>\n<li>不要使用异常控制执行流程</li>\n<li>能合并的操作尽量合并</li>\n<li>注意日志记录对性能的影响</li>\n</ul>\n</li>\n</ol>\n","excerpt":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>拓扑映射是一个用Ruby实现的组网图搜索算法，用于在大的组网图中搜索满足用户要求的小组网。老版本的拓扑映射算法基于老旧的<code>ruby1.8.6</code>，用户已经多次反馈效率低下。听闻ruby推出了新的2.2版本，我们能否利用新版本ruby的高性能呢？</p>\n<h1 id=\"平台级优化\"><a href=\"#平台级优化\" class=\"headerlink\" title=\"平台级优化\"></a>平台级优化</h1><p>我们首先考虑代码不做大改动，切换平台和Ruby版本进行优化。方式如下：</p>\n<ul>\n<li>Ruby升级到最新版本 <strong>2.2</strong></li>\n<li>使用 <strong>Linux</strong> 替换Windows</li>\n</ul>\n<p>我们使用一个运行时间很长的测试数据来测试性能，测试机器都是公司的E6000高配服务器，12核3.2G至强CPU(<code>CRuby</code>只能用单核，多核没意义)。测试结果请参考下图：</p>\n<table>\n<thead>\n<tr>\n<th>Ruby版本</th>\n<th>操作系统</th>\n<th>计算时间（秒）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Ruby 1.8.7</td>\n<td>Windows2008</td>\n<td><code>790</code></td>\n</tr>\n<tr>\n<td>jruby 9.0.0.0.pre1</td>\n<td>Ubuntu 12.04.2/JAVA7</td>\n<td><code>559</code></td>\n</tr>\n<tr>\n<td>Rubinius 2.5.3</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>547</code></td>\n</tr>\n<tr>\n<td>jruby 9.0.0.0.pre1</td>\n<td>Ubuntu 12.04.2/JAVA8</td>\n<td><code>516</code></td>\n</tr>\n<tr>\n<td>Ruby 2.1.3</td>\n<td>Windows2008</td>\n<td><code>436</code></td>\n</tr>\n<tr>\n<td>Ruby 2.1.3</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>324</code></td>\n</tr>\n<tr>\n<td>Ruby 2.2.0</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>314</code></td>\n</tr>\n</tbody>\n</table>\n<p>从数据来看，在Ubuntu平台的Ruby2.2性能最好。在执行过程中，<code>Rubinius</code>出现过随机错误，感觉不是太稳定。</p>","more":"<h1 id=\"代码级优化\"><a href=\"#代码级优化\" class=\"headerlink\" title=\"代码级优化\"></a>代码级优化</h1><p>通过切换操作系统和平台，通过<code>stackprof</code>分析代码性能，进行优化。参考来源见<a href=\"http://tmm1.net/ruby21-profiling/\">tmm1的博客</a>。</p>\n<blockquote>\n<p>注意:</p>\n<ol>\n<li>以下所有优化分析/测试操作都是在Linux上执行的</li>\n<li><code>stackprof</code>使用了Ruby2.1提供的API，因此只支持Ruby2.1以上版本</li>\n</ol>\n</blockquote>\n<h2 id=\"优化ConflictCheck\"><a href=\"#优化ConflictCheck\" class=\"headerlink\" title=\"优化ConflictCheck\"></a>优化ConflictCheck</h2><p>经过测试，发现某些用户开发的插件中，同/跨板约束占据了大量的时间，优化效果不佳，暂时先禁用此优化规则。</p>\n<p>经过此次优化，时间下降到<code>276</code>秒。</p>\n<h2 id=\"优化SlotType约束\"><a href=\"#优化SlotType约束\" class=\"headerlink\" title=\"优化SlotType约束\"></a>优化SlotType约束</h2><p>经过分析，发现约束中的SlotType约束占据了很多时间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">==================================</div><div class=\"line\">  Mode: cpu(1000)</div><div class=\"line\">  Samples: 30019 (0.06% miss rate)</div><div class=\"line\">  GC: 4601 (15.33%)</div><div class=\"line\">==================================</div><div class=\"line\">     TOTAL    (pct)     SAMPLES    (pct)     FRAME</div><div class=\"line\">     13200  (44.0%)       13200  (44.0%)     block in TopoPluginRouter::SlotAux#any?</div><div class=\"line\">       839   (2.8%)         839   (2.8%)     block in TestlibTopo::Topo::Restrict#validate</div></pre></td></tr></table></figure>\n<p>继续跟踪:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">stackprof tmp/perf-result.dump --method &apos;block in TopoPluginRouter::SlotAux#any?&apos;          </div><div class=\"line\">block in TopoPluginRouter::SlotAux#any? (/root/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/topo-plugin-router-2.0.5/lib/topo-plugin-router/dsl/port_dsl.rb:56)</div><div class=\"line\">  samples:  13200 self (44.0%)  /   13200 total (44.0%)</div><div class=\"line\">  callers:</div><div class=\"line\">    13200  (  100.0%)  TopoPluginRouter::SlotAux#any?</div><div class=\"line\">  code:</div><div class=\"line\">                                  |    56  |       items.each &#123; |c|</div><div class=\"line\">                                  |    57  |         c.strip! # 去除空格，防止多余的空格引发判断问题</div><div class=\"line\">                                  |    58  |         c.downcase! # 都转换为小些再比较</div><div class=\"line\">                                  |    59  | </div><div class=\"line\">                                  |    60  |         # 用户如果输入错误，则跳过</div><div class=\"line\">  765    (2.5%) /   765   (2.5%)  |    61  |         next if c.empty?</div><div class=\"line\">                                  |    62  | </div><div class=\"line\">  795    (2.6%) /   795   (2.6%)  |    63  |         if c[0].chr == &apos;!&apos; # 如果是!表达式，则应该不包含此slottype值</div><div class=\"line\">                                  |    64  |           return true if port_slottype !~ /#&#123;c.gsub(/^!/, &apos;&apos;)&#125;/</div><div class=\"line\">                                  |    65  |         else # 普通表达式则包含此slottype值</div><div class=\"line\"> 11640   (38.8%) /  11640  (38.8%)|    66  |           return true if port_slottype =~ /#&#123;c&#125;/</div><div class=\"line\">                                  |    67  |         end</div></pre></td></tr></table></figure>\n<p>可以看到正则表达式匹配占据了大量的时间。</p>\n<p>看看实现原理：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@dtb_to_dta1.slottype(<span class=\"string\">\"*BSU*|*LPUF-21*|*LPUF-40*|*LPUF-51*|*LPUF-101*|*LPUF-120*|*LPUF-240*|*LPUF-20*\"</span>)</div></pre></td></tr></table></figure>\n<p>用户这样写，我们需要把具体的字符串转换为8个正则表达式，一个个进行运算，因此效率很低。其实只需要写一个正则表达式即可。我们给用户提供一个改进版本的方法<code>slottype</code>，支持传入正则表达式。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">REGEX_LPUF_BUS = <span class=\"regexp\">/(BSU|LPUF-(21|40|51|101|120|240)|LPUF-20)/i</span></div><div class=\"line\">@dtb_to_dta1.slottype REGEX_LPUF_BUS</div></pre></td></tr></table></figure>\n<p>这样我们就只需要运算一次正则表达式即可，效率大为提升。</p>\n<p>经过此次改进，时间减少为<code>185</code>秒。</p>\n<h2 id=\"优化top方法\"><a href=\"#优化top方法\" class=\"headerlink\" title=\"优化top方法\"></a>优化top方法</h2><p>缓存<code>top</code>方法，减少计算量。<code>top</code>方法被频繁调用，因此我们可以缓存返回值，减少计算。</p>\n<p>原来：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">top</span></span></div><div class=\"line\">  <span class=\"keyword\">if</span> parent.<span class=\"literal\">nil</span>? <span class=\"keyword\">or</span> parent.parent.<span class=\"literal\">nil</span>?</div><div class=\"line\">    <span class=\"keyword\">self</span></div><div class=\"line\">  <span class=\"keyword\">else</span></div><div class=\"line\">    parent.top</div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>现在：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">top</span></span></div><div class=\"line\">  @top <span class=\"params\">||</span>= <span class=\"keyword\">if</span> parent.<span class=\"literal\">nil</span>? <span class=\"keyword\">or</span> parent.parent.<span class=\"literal\">nil</span>?</div><div class=\"line\">    <span class=\"keyword\">self</span></div><div class=\"line\">  <span class=\"keyword\">else</span></div><div class=\"line\">    parent.top</div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>经过此次优化，时间减少为<code>149</code>秒。</p>\n<h2 id=\"优化Minienv-Env-Connect\"><a href=\"#优化Minienv-Env-Connect\" class=\"headerlink\" title=\"优化Minienv::Env::Connect\"></a>优化Minienv::Env::Connect</h2><p>测试数据:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">stackprof tmp/perf-result.dump --method &apos;Minienv::Env::Connect#src_port&apos; </div><div class=\"line\">Minienv::Env::Connect#src_port (/root/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/minienv-1.0.2/lib/minienv/connect.rb:20)</div><div class=\"line\">  samples:  3373 self (9.0%)  /   3373 total (9.0%)</div><div class=\"line\">  callers:</div><div class=\"line\">     911  (   27.0%)  Minienv::Env::Connect#cross_port</div><div class=\"line\">     864  (   25.6%)  Minienv::Env::Connect#half_cross?</div><div class=\"line\">     796  (   23.6%)  Minienv::Env::Connect#uncross_port</div></pre></td></tr></table></figure>\n<p>可见<code>cross_port</code>,<code>half_cross?</code>,<code>uncross_port</code>访问次数比较多，可以利用缓存减少访问次数。优化原理同上。</p>\n<p>源代码：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cross_port</span></span></div><div class=\"line\">  <span class=\"keyword\">if</span> src_port.top.physical_switch?</div><div class=\"line\">    src_port</div><div class=\"line\">  <span class=\"keyword\">else</span></div><div class=\"line\">    dst_port</div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure></p>\n<p>修改后:<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cross_port</span></span></div><div class=\"line\">  @cross_port <span class=\"params\">||</span>= <span class=\"keyword\">if</span> src_port.top.physical_switch?</div><div class=\"line\">    src_port</div><div class=\"line\">  <span class=\"keyword\">else</span></div><div class=\"line\">    dst_port</div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure></p>\n<p>经过此次优化，时间减少为<code>131</code>秒。</p>\n<h2 id=\"优化TestlibTopo-Match-ConnectorMatcher\"><a href=\"#优化TestlibTopo-Match-ConnectorMatcher\" class=\"headerlink\" title=\"优化TestlibTopo::Match::ConnectorMatcher\"></a>优化TestlibTopo::Match::ConnectorMatcher</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">==================================</div><div class=\"line\">  Mode: cpu(1000)</div><div class=\"line\">  Samples: 32968 (0.05% miss rate)</div><div class=\"line\">  GC: 3441 (10.44%)</div><div class=\"line\">==================================</div><div class=\"line\">     TOTAL    (pct)     SAMPLES    (pct)     FRAME</div><div class=\"line\">      3402  (10.3%)        3365  (10.2%)     rescue in TestlibTopo::Match::ConnectorMatcher#recheck_when_loop</div></pre></td></tr></table></figure>\n<p>跟踪方法输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">rescue in TestlibTopo::Match::ConnectorMatcher#recheck_when_loop (/root/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/hunter-algorithm-2.0.0/lib/hunter/match/rule/connector_matcher.rb:64)</div><div class=\"line\">  samples:  3365 self (10.2%)  /   3402 total (10.3%)</div><div class=\"line\">  callers:</div><div class=\"line\">    3402  (  100.0%)  TestlibTopo::Match::ConnectorMatcher#recheck_when_loop</div><div class=\"line\">  callees (37 total):</div><div class=\"line\">      17  (   45.9%)  Minienv::Envbase#top</div><div class=\"line\">      17  (   45.9%)  Minienv::Env::Connect#src_port</div><div class=\"line\">       3  (    8.1%)  Minienv::Env::Connect#dst_port</div><div class=\"line\">  code:</div><div class=\"line\">                                  |    64  |       yield</div><div class=\"line\">                                  |    65  | </div><div class=\"line\">  284    (0.9%) /   284   (0.9%)  |    66  |     rescue TestlibTopo::MatchException</div><div class=\"line\">                                  |    67  |       # 如果直连链接是自环的，那么要反方向再尝试一次</div><div class=\"line\">   39    (0.1%) /     2   (0.0%)  |    68  |       if env_link.src_port.top == env_link.dst_port.top</div><div class=\"line\">                                  |    69  |         send method_name, env_link, candidate</div><div class=\"line\">                                  |    70  |       else</div><div class=\"line\"> 3079    (9.3%) /  3079   (9.3%)  |    71  |         raise</div><div class=\"line\">                                  |    72  |       end</div></pre></td></tr></table></figure></p>\n<p>可以看到是<code>raise</code>方法占用了大量时间。通过分析代码，发现里面是用了异常来控制执行流程。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">rescue</span> TestlibTopo::MatchException</div><div class=\"line\">  <span class=\"comment\"># 如果直连链接是自环的，那么要反方向再尝试一次</span></div><div class=\"line\">  <span class=\"keyword\">if</span> env_link.src_port.top == env_link.dst_port.top</div><div class=\"line\">    send method_name, env_link, candidate</div><div class=\"line\">  <span class=\"keyword\">else</span></div><div class=\"line\">    raise</div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>用异常控制执行流程代价很高，因此我们将其修改为普通的<code>if else</code>判断即可。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">yield</span></div><div class=\"line\">  <span class=\"literal\">true</span></div><div class=\"line\"><span class=\"keyword\">else</span></div><div class=\"line\">  <span class=\"keyword\">if</span> env_link.src_port.top == env_link.dst_port.top</div><div class=\"line\">    send method_name, env_link, candidate</div><div class=\"line\">  <span class=\"keyword\">else</span></div><div class=\"line\">    <span class=\"literal\">false</span></div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>经过此次优化，时间下降到<code>109</code>秒。</p>\n<h2 id=\"优化Minienv-Envbase-objname\"><a href=\"#优化Minienv-Envbase-objname\" class=\"headerlink\" title=\"优化Minienv::Envbase#objname\"></a>优化Minienv::Envbase#objname</h2><p>继续采样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">==================================</div><div class=\"line\">  Mode: cpu(1000)</div><div class=\"line\">  Samples: 27500 (0.07% miss rate)</div><div class=\"line\">  GC: 2539 (9.23%)</div><div class=\"line\">==================================</div><div class=\"line\">     TOTAL    (pct)     SAMPLES    (pct)     FRAME</div><div class=\"line\">      2780  (10.1%)        2780  (10.1%)     Minienv::Envbase#objname</div></pre></td></tr></table></figure></p>\n<p>跟踪方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Minienv::Envbase#to_s (/root/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/minienv-1.0.3/lib/minienv/env_base.rb:37)</div><div class=\"line\">  samples:    30 self (0.1%)  /   2676 total (9.7%)</div><div class=\"line\">  callers:</div><div class=\"line\">    1401  (   52.4%)  block (2 levels) in &lt;module:TopoPluginRouter&gt;</div><div class=\"line\">     413  (   15.4%)  block (2 levels) in TestlibTopo::Selector::CrossLinkSelector#each</div></pre></td></tr></table></figure></p>\n<p>继续跟踪：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">callees (9787 total):</div><div class=\"line\">  3601  (   36.8%)  Log4r::Logger.[]</div><div class=\"line\">  2090  (   21.4%)  #&lt;Log4r::Logger:0x007f38311ac460&gt;.debug</div></pre></td></tr></table></figure></p>\n<p>我顶，竟然跟踪到日志里面去了。我们之前使用<code>log4r</code>的配置文件中，不是已经把日志关闭了吗？看看代码：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">self</span>.<span class=\"title\">debug</span><span class=\"params\">(str = <span class=\"literal\">nil</span>)</span></span></div><div class=\"line\">  log = Log4r::Logger[<span class=\"string\">'toporesultlogger'</span>]</div><div class=\"line\">  <span class=\"keyword\">if</span> log.debug?</div><div class=\"line\">    <span class=\"keyword\">if</span> block_given?</div><div class=\"line\">      log.debug(<span class=\"keyword\">yield</span>)</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">      log.debug(str)</div><div class=\"line\">    <span class=\"keyword\">end</span></div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>原来log没有缓存，导致每次都访问。还有全局日志设置为<code>DEBUG</code>，导致<code>log.debug(yield)</code>这一句仍然要执行，完全无必要，修改为<code>WARN</code>即可不执行<code>DEBUG</code>语句。</p>\n<p>因此，修改为：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@@log = Log4r::Logger[<span class=\"string\">'toporesultlogger'</span>]</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">self</span>.<span class=\"title\">debug</span><span class=\"params\">(str = <span class=\"literal\">nil</span>)</span></span></div><div class=\"line\">  <span class=\"keyword\">if</span> @@log.debug?</div><div class=\"line\">    <span class=\"keyword\">if</span> block_given?</div><div class=\"line\">      @@log.debug(<span class=\"keyword\">yield</span>)</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">      @@log.debug(str)</div><div class=\"line\">    <span class=\"keyword\">end</span></div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>log4r日志配置文件：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">log4r_config:</span></div><div class=\"line\"><span class=\"attr\">  pre_config:</span></div><div class=\"line\"><span class=\"attr\">    global:</span></div><div class=\"line\"><span class=\"attr\">      level:</span> WARN</div></pre></td></tr></table></figure>\n<p>优化完成后，执行时间为<code>63</code>秒。</p>\n<h2 id=\"优化Minienv-Envbase-parent\"><a href=\"#优化Minienv-Envbase-parent\" class=\"headerlink\" title=\"优化Minienv::Envbase#parent\"></a>优化Minienv::Envbase#parent</h2><p>继续分析，执行采样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">==================================</div><div class=\"line\">  Mode: cpu(1000)</div><div class=\"line\">  Samples: 15961 (0.11% miss rate)</div><div class=\"line\">  GC: 1326 (8.31%)</div><div class=\"line\">==================================</div><div class=\"line\">     TOTAL    (pct)     SAMPLES    (pct)     FRAME</div><div class=\"line\">      1012   (6.3%)        1012   (6.3%)     Minienv::Envbase#parent</div><div class=\"line\">      2064  (12.9%)         946   (5.9%)     Minienv::Envbase#descendants</div></pre></td></tr></table></figure>\n<p>分析parent方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Minienv::Envbase#parent (/root/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/minienv-1.0.3/lib/minienv/env_base.rb:49)</div><div class=\"line\">  samples:  1012 self (6.3%)  /   1012 total (6.3%)</div><div class=\"line\">  callers:</div><div class=\"line\">     413  (   40.8%)  Minienv::Envbase#ancestors</div><div class=\"line\">     282  (   27.9%)  block (2 levels) in &lt;module:TopoPluginRouter&gt;</div><div class=\"line\">     117  (   11.6%)  block in TopoPluginRouter::PortDsl#slottype!</div></pre></td></tr></table></figure></p>\n<p>可见<code>Minienv::Envbase#ancestors</code>耗用时间比较多，应该考虑使用缓存。</p>\n<p>优化后执行时间为<code>59</code>秒。</p>\n<h2 id=\"优化Minienv-Envbase-descendants\"><a href=\"#优化Minienv-Envbase-descendants\" class=\"headerlink\" title=\"优化Minienv::Envbase#descendants\"></a>优化Minienv::Envbase#descendants</h2><p>继续分析：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">==================================</div><div class=\"line\">  Mode: cpu(1000)</div><div class=\"line\">  Samples: 14920 (0.12% miss rate)</div><div class=\"line\">  GC: 1245 (8.34%)</div><div class=\"line\">==================================</div><div class=\"line\">     TOTAL    (pct)     SAMPLES    (pct)     FRAME</div><div class=\"line\">      1988  (13.3%)         890   (6.0%)     Minienv::Envbase#descendants</div></pre></td></tr></table></figure>\n<p>该来的还是会来的……继续做方法缓存。需要注意的是：如果用户的插件不修改组网图，那么方法缓存的数据是没有问题的。如果用户插件修改修改了组网图结构，那么可能会有问题。</p>\n<h2 id=\"优化剩余方法\"><a href=\"#优化剩余方法\" class=\"headerlink\" title=\"优化剩余方法\"></a>优化剩余方法</h2><p>经过分析，基本上都是要缓存方法，就不再详细说明了。</p>\n<h2 id=\"最终结果\"><a href=\"#最终结果\" class=\"headerlink\" title=\"最终结果\"></a>最终结果</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">==================================</div><div class=\"line\">  Mode: cpu(1000)</div><div class=\"line\">  Samples: 11537 (0.16% miss rate)</div><div class=\"line\">  GC: 971 (8.42%)</div><div class=\"line\">==================================</div><div class=\"line\">     TOTAL    (pct)     SAMPLES    (pct)     FRAME</div><div class=\"line\">       704   (6.1%)         704   (6.1%)     Minienv::Env::Connect#src_port</div><div class=\"line\">       623   (5.4%)         623   (5.4%)     block in TestlibTopo::Topo::Restrict#validate</div></pre></td></tr></table></figure>\n<p>最终经过分析，采样的代码基本上都是在执行约束了，没有进一步优化空间。下一步优化只能从算法本身来优化：</p>\n<ul>\n<li>增加优化规则，过滤一些分支</li>\n<li>增加多线程并发运算（<code>CRuby</code>暂时不支持，考虑使用<code>JRuby</code>或者<code>Rubinius</code>）</li>\n</ul>\n<p>最终优化效果：</p>\n<table>\n<thead>\n<tr>\n<th>Ruby版本</th>\n<th>操作系统</th>\n<th>计算时间（秒）</th>\n<th>优化步骤</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Ruby 1.8.7</td>\n<td>Windows2008</td>\n<td><code>790</code></td>\n<td></td>\n</tr>\n<tr>\n<td>jruby 9.0.0.0.pre1</td>\n<td>Ubuntu 12.04.2/JAVA7</td>\n<td><code>559</code></td>\n<td>替换为jruby</td>\n</tr>\n<tr>\n<td>Rubinius 2.5.3</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>547</code></td>\n<td>替换为Rbx</td>\n</tr>\n<tr>\n<td>jruby 9.0.0.0.pre1</td>\n<td>Ubuntu 12.04.2/JAVA8</td>\n<td><code>516</code></td>\n<td>升级Java版本</td>\n</tr>\n<tr>\n<td>Ruby 2.1.3</td>\n<td>Windows2008</td>\n<td><code>436</code></td>\n<td>升级CRuby到<code>2.1.3</code></td>\n</tr>\n<tr>\n<td>Ruby 2.1.3</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>324</code></td>\n<td>替换操作系统为Ubuntu</td>\n</tr>\n<tr>\n<td>Ruby 2.2.0</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>314</code></td>\n<td>升级CRuby到<code>2.2.0</code></td>\n</tr>\n<tr>\n<td>Ruby 2.2.0</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>276</code></td>\n<td>去掉ConflictCheck检查</td>\n</tr>\n<tr>\n<td>Ruby 2.2.0</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>185</code></td>\n<td>优化SlotType约束</td>\n</tr>\n<tr>\n<td>Ruby 2.2.0</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>149</code></td>\n<td>优化top方法</td>\n</tr>\n<tr>\n<td>Ruby 2.2.0</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>131</code></td>\n<td>优化uncross_port方法</td>\n</tr>\n<tr>\n<td>Ruby 2.2.0</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>109</code></td>\n<td>优化ConnectorMatcher类</td>\n</tr>\n<tr>\n<td>Ruby 2.2.0</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>63</code></td>\n<td>优化日志Envbase#objname</td>\n</tr>\n<tr>\n<td>Ruby 2.2.0</td>\n<td>Ubuntu 12.04.2</td>\n<td><code>46</code></td>\n<td>最终优化</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>总结了一下算法优化的方法：</p>\n<ol>\n<li>使用高版本Ruby，一般新版本Ruby在性能方面比老版本都要高</li>\n<li>尽量使用Linux平台，效率上会比Windows平台高</li>\n<li>使用性能分析器(Profiler)对算法进行分析，找到消耗CPU最多的代码进行优化<ul>\n<li>去掉不需要的计算代码</li>\n<li>缓存计算结果，避免重复计算</li>\n<li>不要使用异常控制执行流程</li>\n<li>能合并的操作尽量合并</li>\n<li>注意日志记录对性能的影响</li>\n</ul>\n</li>\n</ol>"},{"title":"使用OCRA将ruby脚本转换为EXE可执行文件运行","date":"2014-11-24T01:05:10.000Z","_content":"__淘汰bat/vbs/js吧！__\n\nOCRA是一个一键式Ruby打包工具，可以将Ruby脚本及所需环境构建为一个单独的Exe文件发布，用户环境上没有Ruby也可以运行！在公司内部作为小工具使用特别方便。\n\n功能：\n\n- LZMA压缩(可选，默认打开)\n- 支持Ruby 1.8.7 / 1.9.3 / 2.0.0 ( __通过RubyInstaller安装的版本__ )\n- 支持命令行和视窗模式\n- 根据使用包含gem包，或者从gemfile包含gem包\n\nOCRA下载：[传送门](http://rubygems.org/gems/ocra)\n\n# 使用介绍\n\nocra的使用方式很简单，只要安装了ocra之后，执行\n\n```\nocra script.rb\n```\n\n即可生成`script.exe`文件，包含`script.rb`文件，Ruby解释器和所有的依赖项（DLL文件和gem包）。\n\n# 实例\n\n对`test.rb`文件打包，生成`print_time.exe`文件：\n\n```\nd:\\work\\open_source\\personal_blog\\gem_roadmap\\problem>ocra D:\\temp\\test.rb --output D:\\temp\\print_time.exe\n=== Loading script to check dependencies\n********************\nTime.now = 2014-02-07 16:52:37 +0800\nTime.now = 2014-02-07 16:52:37 +0800\nTime.now = 2014-02-07 16:52:38 +0800\nTime.now = 2014-02-07 16:52:38 +0800\nTime.now = 2014-02-07 16:52:38 +0800\nTime.now = 2014-02-07 16:52:38 +0800\nTime.now = 2014-02-07 16:52:38 +0800\nTime.now = 2014-02-07 16:52:39 +0800\nTime.now = 2014-02-07 16:52:39 +0800\nTime.now = 2014-02-07 16:52:39 +0800\n********************\n=== Including 53 encoding support files (3194880 bytes, use --no-enc to exclude)\nDL is deprecated, please use Fiddle\n=== Building D:/temp/print_time.exe\n=== Adding user-supplied source files\n=== Adding ruby executable ruby.exe\n=== Adding detected DLL C:/Ruby200/bin/zlib1.dll\n=== Adding detected DLL C:/Ruby200/bin/LIBEAY32.dll\n=== Adding detected DLL C:/Ruby200/bin/SSLEAY32.dll\n=== Adding detected DLL C:/Ruby200/bin/libffi-6.dll\n=== Adding library files\n=== Compressing 10006304 bytes\n=== Finished building D:/temp/print_time.exe (2518489 bytes)\n```\n\n运行后即可生成`print_time.exe`文件，此文件可以在没有安装Ruby的机器中运行。\n\n# **注意事项**\n`1.9.3`之后的RubyInstaller不支持`WindowsXP`和`Windows2003`。如果要支持老版本Windows（公司内部很常见），请制作EXE文件时选择1.9.3版本的Ruby。\n","source":"_posts/use_ocra.md","raw":"title: 使用OCRA将ruby脚本转换为EXE可执行文件运行\ndate: 2014/11/24 9:05:10\ncategories:\n  - ruby\ntags:\n  - ocra\n  - exe\n---\n__淘汰bat/vbs/js吧！__\n\nOCRA是一个一键式Ruby打包工具，可以将Ruby脚本及所需环境构建为一个单独的Exe文件发布，用户环境上没有Ruby也可以运行！在公司内部作为小工具使用特别方便。\n\n功能：\n\n- LZMA压缩(可选，默认打开)\n- 支持Ruby 1.8.7 / 1.9.3 / 2.0.0 ( __通过RubyInstaller安装的版本__ )\n- 支持命令行和视窗模式\n- 根据使用包含gem包，或者从gemfile包含gem包\n\nOCRA下载：[传送门](http://rubygems.org/gems/ocra)\n\n# 使用介绍\n\nocra的使用方式很简单，只要安装了ocra之后，执行\n\n```\nocra script.rb\n```\n\n即可生成`script.exe`文件，包含`script.rb`文件，Ruby解释器和所有的依赖项（DLL文件和gem包）。\n\n# 实例\n\n对`test.rb`文件打包，生成`print_time.exe`文件：\n\n```\nd:\\work\\open_source\\personal_blog\\gem_roadmap\\problem>ocra D:\\temp\\test.rb --output D:\\temp\\print_time.exe\n=== Loading script to check dependencies\n********************\nTime.now = 2014-02-07 16:52:37 +0800\nTime.now = 2014-02-07 16:52:37 +0800\nTime.now = 2014-02-07 16:52:38 +0800\nTime.now = 2014-02-07 16:52:38 +0800\nTime.now = 2014-02-07 16:52:38 +0800\nTime.now = 2014-02-07 16:52:38 +0800\nTime.now = 2014-02-07 16:52:38 +0800\nTime.now = 2014-02-07 16:52:39 +0800\nTime.now = 2014-02-07 16:52:39 +0800\nTime.now = 2014-02-07 16:52:39 +0800\n********************\n=== Including 53 encoding support files (3194880 bytes, use --no-enc to exclude)\nDL is deprecated, please use Fiddle\n=== Building D:/temp/print_time.exe\n=== Adding user-supplied source files\n=== Adding ruby executable ruby.exe\n=== Adding detected DLL C:/Ruby200/bin/zlib1.dll\n=== Adding detected DLL C:/Ruby200/bin/LIBEAY32.dll\n=== Adding detected DLL C:/Ruby200/bin/SSLEAY32.dll\n=== Adding detected DLL C:/Ruby200/bin/libffi-6.dll\n=== Adding library files\n=== Compressing 10006304 bytes\n=== Finished building D:/temp/print_time.exe (2518489 bytes)\n```\n\n运行后即可生成`print_time.exe`文件，此文件可以在没有安装Ruby的机器中运行。\n\n# **注意事项**\n`1.9.3`之后的RubyInstaller不支持`WindowsXP`和`Windows2003`。如果要支持老版本Windows（公司内部很常见），请制作EXE文件时选择1.9.3版本的Ruby。\n","slug":"use_ocra","published":1,"updated":"2016-12-14T14:53:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizij4bj7000cp6dd6qatbdzs","content":"<p><strong>淘汰bat/vbs/js吧！</strong></p>\n<p>OCRA是一个一键式Ruby打包工具，可以将Ruby脚本及所需环境构建为一个单独的Exe文件发布，用户环境上没有Ruby也可以运行！在公司内部作为小工具使用特别方便。</p>\n<p>功能：</p>\n<ul>\n<li>LZMA压缩(可选，默认打开)</li>\n<li>支持Ruby 1.8.7 / 1.9.3 / 2.0.0 ( <strong>通过RubyInstaller安装的版本</strong> )</li>\n<li>支持命令行和视窗模式</li>\n<li>根据使用包含gem包，或者从gemfile包含gem包</li>\n</ul>\n<p>OCRA下载：<a href=\"http://rubygems.org/gems/ocra\" target=\"_blank\" rel=\"external\">传送门</a></p>\n<h1 id=\"使用介绍\"><a href=\"#使用介绍\" class=\"headerlink\" title=\"使用介绍\"></a>使用介绍</h1><p>ocra的使用方式很简单，只要安装了ocra之后，执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ocra script.rb</div></pre></td></tr></table></figure>\n<p>即可生成<code>script.exe</code>文件，包含<code>script.rb</code>文件，Ruby解释器和所有的依赖项（DLL文件和gem包）。</p>\n<h1 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h1><p>对<code>test.rb</code>文件打包，生成<code>print_time.exe</code>文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">d:\\work\\open_source\\personal_blog\\gem_roadmap\\problem&gt;ocra D:\\temp\\test.rb --output D:\\temp\\print_time.exe</div><div class=\"line\">=== Loading script to check dependencies</div><div class=\"line\">********************</div><div class=\"line\">Time.now = 2014-02-07 16:52:37 +0800</div><div class=\"line\">Time.now = 2014-02-07 16:52:37 +0800</div><div class=\"line\">Time.now = 2014-02-07 16:52:38 +0800</div><div class=\"line\">Time.now = 2014-02-07 16:52:38 +0800</div><div class=\"line\">Time.now = 2014-02-07 16:52:38 +0800</div><div class=\"line\">Time.now = 2014-02-07 16:52:38 +0800</div><div class=\"line\">Time.now = 2014-02-07 16:52:38 +0800</div><div class=\"line\">Time.now = 2014-02-07 16:52:39 +0800</div><div class=\"line\">Time.now = 2014-02-07 16:52:39 +0800</div><div class=\"line\">Time.now = 2014-02-07 16:52:39 +0800</div><div class=\"line\">********************</div><div class=\"line\">=== Including 53 encoding support files (3194880 bytes, use --no-enc to exclude)</div><div class=\"line\">DL is deprecated, please use Fiddle</div><div class=\"line\">=== Building D:/temp/print_time.exe</div><div class=\"line\">=== Adding user-supplied source files</div><div class=\"line\">=== Adding ruby executable ruby.exe</div><div class=\"line\">=== Adding detected DLL C:/Ruby200/bin/zlib1.dll</div><div class=\"line\">=== Adding detected DLL C:/Ruby200/bin/LIBEAY32.dll</div><div class=\"line\">=== Adding detected DLL C:/Ruby200/bin/SSLEAY32.dll</div><div class=\"line\">=== Adding detected DLL C:/Ruby200/bin/libffi-6.dll</div><div class=\"line\">=== Adding library files</div><div class=\"line\">=== Compressing 10006304 bytes</div><div class=\"line\">=== Finished building D:/temp/print_time.exe (2518489 bytes)</div></pre></td></tr></table></figure>\n<p>运行后即可生成<code>print_time.exe</code>文件，此文件可以在没有安装Ruby的机器中运行。</p>\n<h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a><strong>注意事项</strong></h1><p><code>1.9.3</code>之后的RubyInstaller不支持<code>WindowsXP</code>和<code>Windows2003</code>。如果要支持老版本Windows（公司内部很常见），请制作EXE文件时选择1.9.3版本的Ruby。</p>\n","excerpt":"","more":"<p><strong>淘汰bat/vbs/js吧！</strong></p>\n<p>OCRA是一个一键式Ruby打包工具，可以将Ruby脚本及所需环境构建为一个单独的Exe文件发布，用户环境上没有Ruby也可以运行！在公司内部作为小工具使用特别方便。</p>\n<p>功能：</p>\n<ul>\n<li>LZMA压缩(可选，默认打开)</li>\n<li>支持Ruby 1.8.7 / 1.9.3 / 2.0.0 ( <strong>通过RubyInstaller安装的版本</strong> )</li>\n<li>支持命令行和视窗模式</li>\n<li>根据使用包含gem包，或者从gemfile包含gem包</li>\n</ul>\n<p>OCRA下载：<a href=\"http://rubygems.org/gems/ocra\">传送门</a></p>\n<h1 id=\"使用介绍\"><a href=\"#使用介绍\" class=\"headerlink\" title=\"使用介绍\"></a>使用介绍</h1><p>ocra的使用方式很简单，只要安装了ocra之后，执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ocra script.rb</div></pre></td></tr></table></figure>\n<p>即可生成<code>script.exe</code>文件，包含<code>script.rb</code>文件，Ruby解释器和所有的依赖项（DLL文件和gem包）。</p>\n<h1 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h1><p>对<code>test.rb</code>文件打包，生成<code>print_time.exe</code>文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">d:\\work\\open_source\\personal_blog\\gem_roadmap\\problem&gt;ocra D:\\temp\\test.rb --output D:\\temp\\print_time.exe</div><div class=\"line\">=== Loading script to check dependencies</div><div class=\"line\">********************</div><div class=\"line\">Time.now = 2014-02-07 16:52:37 +0800</div><div class=\"line\">Time.now = 2014-02-07 16:52:37 +0800</div><div class=\"line\">Time.now = 2014-02-07 16:52:38 +0800</div><div class=\"line\">Time.now = 2014-02-07 16:52:38 +0800</div><div class=\"line\">Time.now = 2014-02-07 16:52:38 +0800</div><div class=\"line\">Time.now = 2014-02-07 16:52:38 +0800</div><div class=\"line\">Time.now = 2014-02-07 16:52:38 +0800</div><div class=\"line\">Time.now = 2014-02-07 16:52:39 +0800</div><div class=\"line\">Time.now = 2014-02-07 16:52:39 +0800</div><div class=\"line\">Time.now = 2014-02-07 16:52:39 +0800</div><div class=\"line\">********************</div><div class=\"line\">=== Including 53 encoding support files (3194880 bytes, use --no-enc to exclude)</div><div class=\"line\">DL is deprecated, please use Fiddle</div><div class=\"line\">=== Building D:/temp/print_time.exe</div><div class=\"line\">=== Adding user-supplied source files</div><div class=\"line\">=== Adding ruby executable ruby.exe</div><div class=\"line\">=== Adding detected DLL C:/Ruby200/bin/zlib1.dll</div><div class=\"line\">=== Adding detected DLL C:/Ruby200/bin/LIBEAY32.dll</div><div class=\"line\">=== Adding detected DLL C:/Ruby200/bin/SSLEAY32.dll</div><div class=\"line\">=== Adding detected DLL C:/Ruby200/bin/libffi-6.dll</div><div class=\"line\">=== Adding library files</div><div class=\"line\">=== Compressing 10006304 bytes</div><div class=\"line\">=== Finished building D:/temp/print_time.exe (2518489 bytes)</div></pre></td></tr></table></figure>\n<p>运行后即可生成<code>print_time.exe</code>文件，此文件可以在没有安装Ruby的机器中运行。</p>\n<h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a><strong>注意事项</strong></h1><p><code>1.9.3</code>之后的RubyInstaller不支持<code>WindowsXP</code>和<code>Windows2003</code>。如果要支持老版本Windows（公司内部很常见），请制作EXE文件时选择1.9.3版本的Ruby。</p>\n"},{"title":"在Windows下使用uru用于多个ruby的切换","date":"2014-11-24T01:05:00.000Z","_content":"\n## Ruby选择器\n\n你还在为如何使用系统中的各个版本的Ruby而烦恼吗？Uru正是为你设计的。\n\n## 如何使用\n\n很简单。\n\n- 在C盘根目录创建一个tools文件夹，然后将tools目录加入系统PATH环境变量，供命令行使用\n- 下载已经编译好的[二进制文件](https://bitbucket.org/jonforums/uru/downloads/uru-0.7.7-windows-x86.7z)，解压到tools目录中\n- 然后打开命令行，执行\n    \n    ```\n    C:\\tools>uru_rt admin install\n    C:\\tools>uru_rt admin add system\n    ```\n\n到此安装完成。\n\n## 增加ruby\n\n也很简单。\n\n- 启动命令行\n- 增加包含ruby.exe的路径到uru中\n\n    ```\n    uru admin add c:\\Ruby193\n    uru admin add c:\\Ruby21\n    ```\n\n- 使用`uru ls`看下当前安装了哪些ruby\n\n    ```\n    d:\\work\\open_source\\super-deploy-script\\ocra>uru ls\n    =>  193p550     : ruby 1.9.3p550 (2014-10-27) [i386-mingw32]\n        213p242     : ruby 2.1.3p242 (2014-09-19 revision 47630) [i386-mingw32]\n        system      : ruby 1.8.7 (2013-06-27 patchlevel 374) [i386-mingw32]\n    ```\n\n## 切换Ruby\n\n然后即可使用`uru 部分名称`来进行ruby的切换，比如：\n\n```\nuru 19      # 切换到ruby 1.9.3p550\n---> Now using ruby 1.9.3-p550 tagged as `193p550`\n\nuru 21      # 切换到ruby 2.1.3p242\n---> Now using ruby 2.1.3-p242 tagged as `213p242`\n\nuru 2       # 切换到ruby 2.1.3p242\n---> Now using ruby 2.1.3-p242 tagged as `213p242`\n```\n\n> 更多的文档可参考uru的[wiki](https://bitbucket.org/jonforums/uru/wiki/Examples)\n","source":"_posts/uru_ruby_select.md","raw":"title: 在Windows下使用uru用于多个ruby的切换\ndate: 2014/11/24 9:05:00\ncategories:\n  - ruby\ntags:\n  - rbenv\n  - ruby\n---\n\n## Ruby选择器\n\n你还在为如何使用系统中的各个版本的Ruby而烦恼吗？Uru正是为你设计的。\n\n## 如何使用\n\n很简单。\n\n- 在C盘根目录创建一个tools文件夹，然后将tools目录加入系统PATH环境变量，供命令行使用\n- 下载已经编译好的[二进制文件](https://bitbucket.org/jonforums/uru/downloads/uru-0.7.7-windows-x86.7z)，解压到tools目录中\n- 然后打开命令行，执行\n    \n    ```\n    C:\\tools>uru_rt admin install\n    C:\\tools>uru_rt admin add system\n    ```\n\n到此安装完成。\n\n## 增加ruby\n\n也很简单。\n\n- 启动命令行\n- 增加包含ruby.exe的路径到uru中\n\n    ```\n    uru admin add c:\\Ruby193\n    uru admin add c:\\Ruby21\n    ```\n\n- 使用`uru ls`看下当前安装了哪些ruby\n\n    ```\n    d:\\work\\open_source\\super-deploy-script\\ocra>uru ls\n    =>  193p550     : ruby 1.9.3p550 (2014-10-27) [i386-mingw32]\n        213p242     : ruby 2.1.3p242 (2014-09-19 revision 47630) [i386-mingw32]\n        system      : ruby 1.8.7 (2013-06-27 patchlevel 374) [i386-mingw32]\n    ```\n\n## 切换Ruby\n\n然后即可使用`uru 部分名称`来进行ruby的切换，比如：\n\n```\nuru 19      # 切换到ruby 1.9.3p550\n---> Now using ruby 1.9.3-p550 tagged as `193p550`\n\nuru 21      # 切换到ruby 2.1.3p242\n---> Now using ruby 2.1.3-p242 tagged as `213p242`\n\nuru 2       # 切换到ruby 2.1.3p242\n---> Now using ruby 2.1.3-p242 tagged as `213p242`\n```\n\n> 更多的文档可参考uru的[wiki](https://bitbucket.org/jonforums/uru/wiki/Examples)\n","slug":"uru_ruby_select","published":1,"updated":"2016-12-14T14:53:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizij4bjb000fp6ddk9pl9dlb","content":"<h2 id=\"Ruby选择器\"><a href=\"#Ruby选择器\" class=\"headerlink\" title=\"Ruby选择器\"></a>Ruby选择器</h2><p>你还在为如何使用系统中的各个版本的Ruby而烦恼吗？Uru正是为你设计的。</p>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p>很简单。</p>\n<ul>\n<li>在C盘根目录创建一个tools文件夹，然后将tools目录加入系统PATH环境变量，供命令行使用</li>\n<li>下载已经编译好的<a href=\"https://bitbucket.org/jonforums/uru/downloads/uru-0.7.7-windows-x86.7z\" target=\"_blank\" rel=\"external\">二进制文件</a>，解压到tools目录中</li>\n<li><p>然后打开命令行，执行</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">C:\\tools&gt;uru_rt admin install</div><div class=\"line\">C:\\tools&gt;uru_rt admin add system</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>到此安装完成。</p>\n<h2 id=\"增加ruby\"><a href=\"#增加ruby\" class=\"headerlink\" title=\"增加ruby\"></a>增加ruby</h2><p>也很简单。</p>\n<ul>\n<li>启动命令行</li>\n<li><p>增加包含ruby.exe的路径到uru中</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">uru admin add c:\\Ruby193</div><div class=\"line\">uru admin add c:\\Ruby21</div></pre></td></tr></table></figure>\n</li>\n<li><p>使用<code>uru ls</code>看下当前安装了哪些ruby</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">d:\\work\\open_source\\super-deploy-script\\ocra&gt;uru ls</div><div class=\"line\">=&gt;  193p550     : ruby 1.9.3p550 (2014-10-27) [i386-mingw32]</div><div class=\"line\">    213p242     : ruby 2.1.3p242 (2014-09-19 revision 47630) [i386-mingw32]</div><div class=\"line\">    system      : ruby 1.8.7 (2013-06-27 patchlevel 374) [i386-mingw32]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"切换Ruby\"><a href=\"#切换Ruby\" class=\"headerlink\" title=\"切换Ruby\"></a>切换Ruby</h2><p>然后即可使用<code>uru 部分名称</code>来进行ruby的切换，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">uru 19      # 切换到ruby 1.9.3p550</div><div class=\"line\">---&gt; Now using ruby 1.9.3-p550 tagged as `193p550`</div><div class=\"line\"></div><div class=\"line\">uru 21      # 切换到ruby 2.1.3p242</div><div class=\"line\">---&gt; Now using ruby 2.1.3-p242 tagged as `213p242`</div><div class=\"line\"></div><div class=\"line\">uru 2       # 切换到ruby 2.1.3p242</div><div class=\"line\">---&gt; Now using ruby 2.1.3-p242 tagged as `213p242`</div></pre></td></tr></table></figure>\n<blockquote>\n<p>更多的文档可参考uru的<a href=\"https://bitbucket.org/jonforums/uru/wiki/Examples\" target=\"_blank\" rel=\"external\">wiki</a></p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"Ruby选择器\"><a href=\"#Ruby选择器\" class=\"headerlink\" title=\"Ruby选择器\"></a>Ruby选择器</h2><p>你还在为如何使用系统中的各个版本的Ruby而烦恼吗？Uru正是为你设计的。</p>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p>很简单。</p>\n<ul>\n<li>在C盘根目录创建一个tools文件夹，然后将tools目录加入系统PATH环境变量，供命令行使用</li>\n<li>下载已经编译好的<a href=\"https://bitbucket.org/jonforums/uru/downloads/uru-0.7.7-windows-x86.7z\">二进制文件</a>，解压到tools目录中</li>\n<li><p>然后打开命令行，执行</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">C:\\tools&gt;uru_rt admin install</div><div class=\"line\">C:\\tools&gt;uru_rt admin add system</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>到此安装完成。</p>\n<h2 id=\"增加ruby\"><a href=\"#增加ruby\" class=\"headerlink\" title=\"增加ruby\"></a>增加ruby</h2><p>也很简单。</p>\n<ul>\n<li>启动命令行</li>\n<li><p>增加包含ruby.exe的路径到uru中</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">uru admin add c:\\Ruby193</div><div class=\"line\">uru admin add c:\\Ruby21</div></pre></td></tr></table></figure>\n</li>\n<li><p>使用<code>uru ls</code>看下当前安装了哪些ruby</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">d:\\work\\open_source\\super-deploy-script\\ocra&gt;uru ls</div><div class=\"line\">=&gt;  193p550     : ruby 1.9.3p550 (2014-10-27) [i386-mingw32]</div><div class=\"line\">    213p242     : ruby 2.1.3p242 (2014-09-19 revision 47630) [i386-mingw32]</div><div class=\"line\">    system      : ruby 1.8.7 (2013-06-27 patchlevel 374) [i386-mingw32]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"切换Ruby\"><a href=\"#切换Ruby\" class=\"headerlink\" title=\"切换Ruby\"></a>切换Ruby</h2><p>然后即可使用<code>uru 部分名称</code>来进行ruby的切换，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">uru 19      # 切换到ruby 1.9.3p550</div><div class=\"line\">---&gt; Now using ruby 1.9.3-p550 tagged as `193p550`</div><div class=\"line\"></div><div class=\"line\">uru 21      # 切换到ruby 2.1.3p242</div><div class=\"line\">---&gt; Now using ruby 2.1.3-p242 tagged as `213p242`</div><div class=\"line\"></div><div class=\"line\">uru 2       # 切换到ruby 2.1.3p242</div><div class=\"line\">---&gt; Now using ruby 2.1.3-p242 tagged as `213p242`</div></pre></td></tr></table></figure>\n<blockquote>\n<p>更多的文档可参考uru的<a href=\"https://bitbucket.org/jonforums/uru/wiki/Examples\">wiki</a></p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cizij4bim0001p6ddmlm0zr02","category_id":"cizij4bis0003p6ddylbvqxn5","_id":"cizij4bj6000bp6ddlkd9kz05"},{"post_id":"cizij4bj2000ap6dd8axr0jqf","category_id":"cizij4bj00008p6dda22gnci3","_id":"cizij4bjd000gp6ddsqg1ta9u"},{"post_id":"cizij4bip0002p6ddo321jfip","category_id":"cizij4bj00008p6dda22gnci3","_id":"cizij4bjf000jp6ddougoxcfv"},{"post_id":"cizij4bj7000cp6dd6qatbdzs","category_id":"cizij4bj00008p6dda22gnci3","_id":"cizij4bjg000lp6ddx141quhx"},{"post_id":"cizij4bjb000fp6ddk9pl9dlb","category_id":"cizij4bj00008p6dda22gnci3","_id":"cizij4bjh000op6ddw4b2jmo5"},{"post_id":"cizij4biu0005p6ddr17vas9g","category_id":"cizij4bj00008p6dda22gnci3","_id":"cizij4bji000rp6ddu1wmtd0b"},{"post_id":"cizij4bix0006p6ddyxe69i4y","category_id":"cizij4bje000hp6ddg84j2mo3","_id":"cizij4bjj000sp6dd7m8elsqs"},{"post_id":"cizij4bj00007p6ddu6bff1xu","category_id":"cizij4bj00008p6dda22gnci3","_id":"cizij4bjk000vp6dd4zoeb7st"}],"PostTag":[{"post_id":"cizij4bim0001p6ddmlm0zr02","tag_id":"cizij4biu0004p6ddiz39bbmm","_id":"cizij4bjf000kp6ddsmo7jj6a"},{"post_id":"cizij4bim0001p6ddmlm0zr02","tag_id":"cizij4bj10009p6ddwwjfd6bv","_id":"cizij4bjg000mp6dd37ka6zht"},{"post_id":"cizij4bim0001p6ddmlm0zr02","tag_id":"cizij4bj8000ep6dd3v3mwlh2","_id":"cizij4bjh000qp6ddbuw8nv09"},{"post_id":"cizij4bip0002p6ddo321jfip","tag_id":"cizij4bjf000ip6ddfowfox9p","_id":"cizij4bjk000up6ddbyzq43gt"},{"post_id":"cizij4bip0002p6ddo321jfip","tag_id":"cizij4bjh000pp6ddkmt9e8r8","_id":"cizij4bjk000wp6ddmp6883pb"},{"post_id":"cizij4biu0005p6ddr17vas9g","tag_id":"cizij4bjj000tp6dd7i0xjugt","_id":"cizij4bjm000zp6ddqw3icqvh"},{"post_id":"cizij4biu0005p6ddr17vas9g","tag_id":"cizij4bjl000xp6ddf4x3k3cb","_id":"cizij4bjm0010p6dd2b510mfl"},{"post_id":"cizij4bix0006p6ddyxe69i4y","tag_id":"cizij4bjl000yp6dd3835ngm2","_id":"cizij4bjo0012p6dd9xbrf9nu"},{"post_id":"cizij4bj00007p6ddu6bff1xu","tag_id":"cizij4bjo0011p6dd1o8r4qnj","_id":"cizij4bjq0014p6ddpolx8ejq"},{"post_id":"cizij4bj2000ap6dd8axr0jqf","tag_id":"cizij4bjp0013p6ddz4ypfrws","_id":"cizij4bjw0018p6ddcxq6cev8"},{"post_id":"cizij4bj2000ap6dd8axr0jqf","tag_id":"cizij4bjl000xp6ddf4x3k3cb","_id":"cizij4bjw0019p6dd8qqspuxe"},{"post_id":"cizij4bj2000ap6dd8axr0jqf","tag_id":"cizij4bjt0016p6ddepnsazlb","_id":"cizij4bjx001bp6dd78tb0t45"},{"post_id":"cizij4bj7000cp6dd6qatbdzs","tag_id":"cizij4bjw0017p6dd7b32mkj3","_id":"cizij4bjx001dp6ddeeit3cy2"},{"post_id":"cizij4bj7000cp6dd6qatbdzs","tag_id":"cizij4bjx001ap6ddlzchuzuh","_id":"cizij4bjx001ep6dd8s5w1ram"},{"post_id":"cizij4bjb000fp6ddk9pl9dlb","tag_id":"cizij4bjx001cp6dd628v7885","_id":"cizij4bjy001gp6dd8s2li3ra"},{"post_id":"cizij4bjb000fp6ddk9pl9dlb","tag_id":"cizij4bjl000xp6ddf4x3k3cb","_id":"cizij4bjy001hp6dd2sj6vybt"}],"Tag":[{"name":"clean","_id":"cizij4biu0004p6ddiz39bbmm"},{"name":"docker","_id":"cizij4bj10009p6ddwwjfd6bv"},{"name":"shell","_id":"cizij4bj8000ep6dd3v3mwlh2"},{"name":"gil","_id":"cizij4bjf000ip6ddfowfox9p"},{"name":"并发","_id":"cizij4bjh000pp6ddkmt9e8r8"},{"name":"json","_id":"cizij4bjj000tp6dd7i0xjugt"},{"name":"ruby","_id":"cizij4bjl000xp6ddf4x3k3cb"},{"name":"性能","_id":"cizij4bjl000yp6dd3835ngm2"},{"name":"覆盖率","_id":"cizij4bjo0011p6dd1o8r4qnj"},{"name":"stackprof","_id":"cizij4bjp0013p6ddz4ypfrws"},{"name":"优化","_id":"cizij4bjt0016p6ddepnsazlb"},{"name":"ocra","_id":"cizij4bjw0017p6dd7b32mkj3"},{"name":"exe","_id":"cizij4bjx001ap6ddlzchuzuh"},{"name":"rbenv","_id":"cizij4bjx001cp6dd628v7885"}]}}